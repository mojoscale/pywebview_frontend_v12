{
  "actuators.fast_accel_stepper": {
    "doc": "FastAccelStepper Python Wrapper for ESP32 and Arduino boards.\n\nA high-speed stepper motor control library providing acceleration/deceleration,\nnon-blocking movement, and multi-motor support. This wrapper provides a Pythonic\ninterface to the underlying C++ FastAccelStepper library.\n\nClasses:\n    FastAccelStepperEngine: Factory and resource manager for stepper motors\n    FastAccelStepper: Individual stepper motor controller\n\nExample:\n    Basic usage with blocking movement:\n    \n    >>> engine = FastAccelStepperEngine()\n    >>> engine.init()\n    >>> stepper = engine.stepper_connect_to_pin(9)\n    >>> if stepper:\n    ...     stepper.set_direction_pin(5)\n    ...     stepper.set_enable_pin(6)\n    ...     stepper.set_speed_hz(500)\n    ...     stepper.set_acceleration(100)\n    ...     stepper.move_to(1000, True)  # Blocking move\n\n    Non-blocking movement with status polling:\n    \n    >>> stepper.move_to(5000)  # Start non-blocking move\n    >>> while stepper.is_running():\n    ...     # Do other work\n    ...     pass",
    "functions": [],
    "classes": [
      {
        "name": "FastAccelStepperEngine",
        "doc": "Factory and resource manager for stepper motors.\n\nThe engine manages hardware resources (timers, modules, interrupts) and\ncoordinates multiple stepper motors. It handles platform-specific complexity\nand ensures efficient resource allocation.\n\nOn ESP32: Manages MCPWM, RMT, and pulse counter modules\nOn AVR: Manages timer allocation\nOn Pico: Manages PIO state machines\n\nAttributes:\n    None (engine manages resources internally)",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "doc": "Initialize the FastAccelStepperEngine factory.\n\nCreates an engine instance. Must call init() before connecting steppers.\n\nReturns:\n    FastAccelStepperEngine: New engine instance"
          },
          {
            "name": "init",
            "signature": "(self) -> None",
            "doc": "Initialize the stepper engine and allocate hardware resources.\n\nSets up interrupt handlers, timers, and tasks needed for stepper control.\nMust be called in setup() before connecting any steppers.\n\nOn ESP32, the stepper task runs on the default core. This method is\nblocking only for setup duration.\n\nArgs:\n    None\n\nReturns:\n    None\n\nRaises:\n    RuntimeError: If hardware resources are unavailable\n\nExample:\n    >>> engine = FastAccelStepperEngine()\n    >>> engine.init()"
          },
          {
            "name": "stepper_connect_to_pin",
            "signature": "(self, step_pin: int) -> FastAccelStepper",
            "doc": "Create and connect a new stepper to a step pin.\n\nAllocates hardware resources (timer/module) and creates a FastAccelStepper\ninstance for control. Returns None if the pin cannot be used or no\nresources are available.\n\nStep pin restrictions vary by platform:\n- AVR Nano/Uno: Pins 9, 10\n- AVR Mega2560: Pins 6, 7, 8\n- ESP32: Any GPIO pin\n- Pico: Any GPIO up to 31\n\nArgs:\n    step_pin (int): GPIO pin number for step signal\n\nReturns:\n    FastAccelStepper: New stepper instance, or None if allocation failed\n\nExample:\n    >>> stepper = engine.stepper_connect_to_pin(9)\n    >>> if stepper:\n    ...     stepper.set_direction_pin(5)"
          }
        ]
      },
      {
        "name": "FastAccelStepper",
        "doc": "Individual stepper motor controller with acceleration support.\n\nManages a single stepper motor including speed, acceleration, and position.\nThe controller is fully non-blocking - no periodic function calls required\nin the main loop. All timing is interrupt-driven.\n\nAttributes:\n    None (state managed internally by C++ driver)\n\nNote:\n    Do not instantiate directly. Use FastAccelStepperEngine.stepper_connect_to_pin()",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "doc": "No docstring available"
          },
          {
            "name": "set_direction_pin",
            "signature": "(self, pin: int) -> None",
            "doc": "Configure the direction control pin.\n\nSets the GPIO pin used to control stepper direction. Direction signal\ntransitions should allow adequate settling time (see set_direction_delay).\nBy default, HIGH counts up and LOW counts down.\n\nArgs:\n    pin (int): GPIO pin number for direction control\n\nReturns:\n    None\n\nExample:\n    >>> stepper.set_direction_pin(5)"
          },
          {
            "name": "get_direction_pin",
            "signature": "(self) -> int",
            "doc": "Get the configured direction pin.\n\nReturns the GPIO pin number that was set for direction control.\n\nArgs:\n    None\n\nReturns:\n    int: GPIO pin number for direction control\n\nExample:\n    >>> pin = stepper.get_direction_pin()"
          },
          {
            "name": "direction_pin_high_counts_up",
            "signature": "(self) -> bool",
            "doc": "Get the direction pin polarity setting.\n\nReturns whether HIGH on the direction pin counts up (True) or down (False).\n\nArgs:\n    None\n\nReturns:\n    bool: True if HIGH counts up, False if HIGH counts down\n\nExample:\n    >>> if stepper.direction_pin_high_counts_up():\n    ...     print(\"HIGH = forward\")"
          },
          {
            "name": "set_enable_pin",
            "signature": "(self, pin: int, low_active: bool = True) -> None",
            "doc": "Configure the motor enable pin.\n\nSets the GPIO pin used to enable/disable the stepper driver. By default,\nLOW activates the driver.\n\nArgs:\n    pin (int): GPIO pin number for enable control\n    low_active (bool): If True (default), LOW enables driver.\n                      If False, HIGH enables driver.\n\nReturns:\n    None\n\nExample:\n    >>> stepper.set_enable_pin(6)\n    >>> stepper.set_enable_pin(6, False)  # HIGH enables"
          },
          {
            "name": "get_enable_pin_low_active",
            "signature": "(self) -> int",
            "doc": "Get the low-active enable pin number.\n\nReturns the GPIO pin configured for low-active enable (if any).\n\nArgs:\n    None\n\nReturns:\n    int: GPIO pin number or 0 if not configured\n\nExample:\n    >>> pin = stepper.get_enable_pin_low_active()"
          },
          {
            "name": "get_enable_pin_high_active",
            "signature": "(self) -> int",
            "doc": "Get the high-active enable pin number.\n\nReturns the GPIO pin configured for high-active enable (if any).\n\nArgs:\n    None\n\nReturns:\n    int: GPIO pin number or 0 if not configured\n\nExample:\n    >>> pin = stepper.get_enable_pin_high_active()"
          },
          {
            "name": "set_auto_enable",
            "signature": "(self, enable: bool) -> None",
            "doc": "Enable automatic motor enable/disable with movement.\n\nWhen enabled, the motor is automatically powered on when movement starts\nand powers off when movement completes. Reduces power dissipation and\nheat generation during idle periods.\n\nArgs:\n    enable (bool): True to enable auto enable/disable, False for manual control\n\nReturns:\n    None\n\nExample:\n    >>> stepper.set_auto_enable(True)"
          },
          {
            "name": "set_delay_to_enable",
            "signature": "(self, delay_us: int) -> int",
            "doc": "Set delay between enable and first step.\n\nSpecifies the time the motor driver has to stabilize after being enabled\nbefore the first step pulse is issued.\n\nArgs:\n    delay_us (int): Delay in microseconds (max ~120ms on ESP32)\n\nReturns:\n    int: DelayResultCode (0 = DELAY_OK, -1 = out of range)\n\nExample:\n    >>> stepper.set_delay_to_enable(500)  # 500 microseconds"
          },
          {
            "name": "set_delay_to_disable",
            "signature": "(self, delay_ms: int) -> None",
            "doc": "Set delay between last step and disable.\n\nSpecifies the time to wait after the last step before disabling the motor.\n\nArgs:\n    delay_ms (int): Delay in milliseconds\n\nReturns:\n    None\n\nExample:\n    >>> stepper.set_delay_to_disable(5)  # 5 milliseconds"
          },
          {
            "name": "set_speed_hz",
            "signature": "(self, speed_hz: int) -> int",
            "doc": "Set stepper speed in steps per second.\n\nSets the target speed for movement. Speed is applied to the next\nmove/moveTo/runForward/runBackward call. Changes to a running motor\nrequire calling move() again to take effect.\n\nValid range: ~244 Hz (minimum) to hardware maximum (~92kHz on ESP32).\nHardware maximum depends on CPU frequency and driver module.\n\nArgs:\n    speed_hz (int): Target speed in steps per second (Hz)\n\nReturns:\n    int: 0 on success, -1 if speed exceeds hardware limits\n\nExample:\n    >>> result = stepper.set_speed_hz(500)\n    >>> if result == 0:\n    ...     print(\"Speed set successfully\")"
          },
          {
            "name": "set_speed_us",
            "signature": "(self, step_us: int) -> int",
            "doc": "Set stepper speed in microseconds per step.\n\nAlternative to set_speed_hz() using microsecond resolution.\nUseful for very precise speed control or when working with timing constants.\n\nArgs:\n    step_us (int): Minimum time between steps in microseconds\n\nReturns:\n    int: 0 on success, -1 if speed is invalid\n\nExample:\n    >>> stepper.set_speed_us(2000)  # 2ms per step = 500 Hz"
          },
          {
            "name": "set_speed_ticks",
            "signature": "(self, step_ticks: int) -> int",
            "doc": "Set stepper speed in CPU ticks per step.\n\nLow-level API for experienced users. Ticks depend on CPU frequency.\nAt 16MHz: 1 tick = 62.5ns, at 240MHz (ESP32): 1 tick = 4.17ns.\n\nArgs:\n    step_ticks (int): Minimum ticks between steps\n\nReturns:\n    int: 0 on success, -1 if speed is invalid\n\nExample:\n    >>> stepper.set_speed_ticks(3200)"
          },
          {
            "name": "set_speed_millihz",
            "signature": "(self, speed_millihz: int) -> int",
            "doc": "Set stepper speed in millihertz (steps per 1000 seconds).\n\nFor very slow speeds. Useful for applications requiring sub-Hz control\nlike automated plant waterers or time-lapse mechanisms.\n\nArgs:\n    speed_millihz (int): Speed in millihertz\n\nReturns:\n    int: 0 on success, -1 if speed is invalid\n\nExample:\n    >>> stepper.set_speed_millihz(100)  # 0.1 steps per second"
          },
          {
            "name": "get_speed_us",
            "signature": "(self) -> int",
            "doc": "Get configured speed in microseconds per step.\n\nReturns the speed that was set, not accounting for acceleration.\n\nArgs:\n    None\n\nReturns:\n    int: Speed in microseconds per step\n\nExample:\n    >>> speed_us = stepper.get_speed_us()"
          },
          {
            "name": "get_speed_ticks",
            "signature": "(self) -> int",
            "doc": "Get configured speed in CPU ticks per step.\n\nReturns the speed that was set in ticks.\n\nArgs:\n    None\n\nReturns:\n    int: Speed in ticks per step\n\nExample:\n    >>> speed_ticks = stepper.get_speed_ticks()"
          },
          {
            "name": "get_speed_millihz",
            "signature": "(self) -> int",
            "doc": "Get configured speed in millihertz.\n\nReturns the speed that was set in millihertz.\n\nArgs:\n    None\n\nReturns:\n    int: Speed in millihertz\n\nExample:\n    >>> speed_mhz = stepper.get_speed_millihz()"
          },
          {
            "name": "get_current_speed_us",
            "signature": "(self) -> int",
            "doc": "Get actual current speed in microseconds per step.\n\nReturns the actual speed being executed, accounting for acceleration.\nDuring ramp-up/down, this changes over time. Returns negative during\nbackward movement.\n\nArgs:\n    None\n\nReturns:\n    int: Current speed in microseconds per step (negative = backward)\n\nExample:\n    >>> current_speed = stepper.get_current_speed_us()"
          },
          {
            "name": "get_current_speed_millihz",
            "signature": "(self) -> int",
            "doc": "Get actual current speed in millihertz.\n\nReturns the actual speed being executed, accounting for acceleration.\n\nArgs:\n    None\n\nReturns:\n    int: Current speed in millihertz (negative = backward)\n\nExample:\n    >>> current_speed = stepper.get_current_speed_millihz()"
          },
          {
            "name": "get_max_speed_hz",
            "signature": "(self) -> int",
            "doc": "Get hardware maximum speed in Hz.\n\nReturns the maximum achievable speed on this hardware.\n\nArgs:\n    None\n\nReturns:\n    int: Maximum speed in Hz\n\nExample:\n    >>> max_hz = stepper.get_max_speed_hz()"
          },
          {
            "name": "get_max_speed_us",
            "signature": "(self) -> int",
            "doc": "Get hardware maximum speed in microseconds per step.\n\nReturns the maximum achievable speed on this hardware.\n\nArgs:\n    None\n\nReturns:\n    int: Minimum microseconds per step\n\nExample:\n    >>> max_speed_us = stepper.get_max_speed_us()"
          },
          {
            "name": "get_max_speed_ticks",
            "signature": "(self) -> int",
            "doc": "Get hardware maximum speed in CPU ticks per step.\n\nReturns the maximum achievable speed on this hardware.\n\nArgs:\n    None\n\nReturns:\n    int: Minimum ticks per step\n\nExample:\n    >>> max_speed_ticks = stepper.get_max_speed_ticks()"
          },
          {
            "name": "get_max_speed_millihz",
            "signature": "(self) -> int",
            "doc": "Get hardware maximum speed in millihertz.\n\nReturns the maximum achievable speed on this hardware.\n\nArgs:\n    None\n\nReturns:\n    int: Maximum speed in millihertz\n\nExample:\n    >>> max_speed_mhz = stepper.get_max_speed_millihz()"
          },
          {
            "name": "set_acceleration",
            "signature": "(self, acceleration: int) -> int",
            "doc": "Set acceleration in steps per second squared.\n\nControls how quickly the motor ramps between speeds. Higher values\nmean faster acceleration but may lose steps if too aggressive.\n\nValid range: > 0\n\nArgs:\n    acceleration (int): Acceleration in steps/second\u00b2\n\nReturns:\n    int: 0 on success, -1 if acceleration <= 0\n\nExample:\n    >>> stepper.set_acceleration(500)  # Ramp up 500 steps/s each second"
          },
          {
            "name": "get_acceleration",
            "signature": "(self) -> int",
            "doc": "Get configured acceleration.\n\nReturns the acceleration value that was set.\n\nArgs:\n    None\n\nReturns:\n    int: Acceleration in steps/second\u00b2\n\nExample:\n    >>> accel = stepper.get_acceleration()"
          },
          {
            "name": "get_current_acceleration",
            "signature": "(self) -> int",
            "doc": "Get current acceleration being applied.\n\nReturns the actual acceleration during ramping, or 0 when idle/coasting.\nPositive = accelerating forward, Negative = accelerating backward.\n\nArgs:\n    None\n\nReturns:\n    int: Current acceleration in steps/second\u00b2 (0 = not accelerating)\n\nExample:\n    >>> current_accel = stepper.get_current_acceleration()"
          },
          {
            "name": "set_linear_acceleration",
            "signature": "(self, linear_accel_steps: int) -> None",
            "doc": "Set linear acceleration ramp-in.\n\nCreates a smooth transition into constant acceleration. Reduces mechanical\nstress by ramping acceleration linearly up from zero.\n\nArgs:\n    linear_accel_steps (int): Number of steps over which to ramp in acceleration\n\nReturns:\n    None\n\nExample:\n    >>> stepper.set_linear_acceleration(100)  # Ramp over 100 steps"
          },
          {
            "name": "set_jump_start",
            "signature": "(self, jump_step: int) -> None",
            "doc": "Set jump start step for smoother motion from standstill.\n\nAllows starting from a non-zero ramp step, providing smoother initial\nacceleration from rest.\n\nArgs:\n    jump_step (int): Ramp step to start from\n\nReturns:\n    None\n\nExample:\n    >>> stepper.set_jump_start(10)"
          },
          {
            "name": "apply_speed_acceleration",
            "signature": "(self) -> None",
            "doc": "Apply new speed and acceleration values to current movement.\n\nUpdates running motor with new speed/acceleration parameters without\nstopping. Useful for real-time speed adjustments.\n\nArgs:\n    None\n\nReturns:\n    None\n\nExample:\n    >>> stepper.set_speed_hz(1000)\n    >>> stepper.apply_speed_acceleration()"
          },
          {
            "name": "move",
            "signature": "(self, steps: int, blocking: bool = False) -> dict[str, int]",
            "doc": "Move stepper by relative number of steps.\n\nIf motor is running, updates the target relative to current target.\nDoes not allow reversing direction of ongoing movement.\n\nArgs:\n    steps (int): Number of steps (positive = forward, negative = backward)\n    blocking (bool): If True, wait for command to complete\n\nReturns:\n    dict[str, int]: Dictionary with step movement result.\n    Contains:\n    {\n        \"result_code\": int,   # MoveResultCode (0 = success)\n        \"steps\": int,         # Number of steps commanded\n        \"blocking\": int,      # 1 if blocking, 0 if non-blocking\n        \"success\": int        # 1 if result_code == 0 else 0\n    }\n\n\nExample:\n    >>> stepper.move(500)  # Move 500 steps forward\n    >>> stepper.move(-100)  # Move 100 steps backward"
          },
          {
            "name": "move_to",
            "signature": "(self, position: int, blocking: bool = False) -> dict[str, int]",
            "doc": "Move stepper to absolute position.\n\nSets target position for the motor. Motor will accelerate/decelerate\nas needed to reach target.\n\nArgs:\n    position (int): Target absolute position\n    blocking (bool): If True, wait for command to complete\n\nReturns:\n    dict[str, int]: Dictionary with absolute move result.\n    Contains\n    {\n        \"result_code\": int,   # MoveResultCode (0 = success)\n        \"position\": int,      # Target absolute position\n        \"blocking\": int,      # 1 if blocking, 0 if non-blocking\n        \"success\": int        # 1 if result_code == 0 else 0\n    }\n\n\nExample:\n    >>> stepper.move_to(5000)  # Move to position 5000"
          },
          {
            "name": "run_forward",
            "signature": "(self) -> dict[str, int]",
            "doc": "Run motor continuously forward.\n\nMotor will accelerate to set speed and continue until stopped.\n\nArgs:\n    None\n\nReturns:\n    dict[str, int]: Dictionary describing forward run status.\n    Contains\n    {\n        \"result_code\": int,   # MoveResultCode (0 = success)\n        \"operation\": 1,       # 1 = forward direction\n        \"success\": int        # 1 if result_code == 0 else 0\n    }\n\n\nExample:\n    >>> stepper.run_forward()\n    >>> # ... later ...\n    >>> stepper.stop_move()"
          },
          {
            "name": "run_backward",
            "signature": "(self) -> dict[str, int]",
            "doc": "Run motor continuously backward.\n\nMotor will accelerate to set speed and continue until stopped.\nRequires direction pin to be configured.\n\nArgs:\n    None\n\nReturns:\n    dict[str, int]: Dictionary describing backward run status.\n    Contains\n    {\n        \"result_code\": int,   # MoveResultCode (0 = success)\n        \"operation\": -1,      # -1 = backward direction\n        \"success\": int        # 1 if result_code == 0 else 0\n    }\n\n\nExample:\n    >>> stepper.run_backward()\n    >>> # ... later ...\n    >>> stepper.stop_move()"
          },
          {
            "name": "keep_running",
            "signature": "(self) -> None",
            "doc": "Keep running in current direction.\n\nPrevents motor from stopping; maintains current direction and acceleration.\n\nArgs:\n    None\n\nReturns:\n    None\n\nExample:\n    >>> stepper.keep_running()"
          },
          {
            "name": "is_running_continuously",
            "signature": "(self) -> bool",
            "doc": "Check if motor is set to run continuously.\n\nReturns True if in continuous run mode (runForward/runBackward).\n\nArgs:\n    None\n\nReturns:\n    bool: True if running continuously\n\nExample:\n    >>> if stepper.is_running_continuously():\n    ...     print(\"Motor is in continuous run mode\")"
          },
          {
            "name": "forward_step",
            "signature": "(self, blocking: bool = False) -> None",
            "doc": "Execute single step forward.\n\nPerforms one forward step immediately. Motor must not be moving.\n\nArgs:\n    blocking (bool): If True, wait for step to complete\n\nReturns:\n    None\n\nExample:\n    >>> stepper.forward_step()"
          },
          {
            "name": "backward_step",
            "signature": "(self, blocking: bool = False) -> None",
            "doc": "Execute single step backward.\n\nPerforms one backward step immediately. Motor must not be moving.\nRequires direction pin to be configured.\n\nArgs:\n    blocking (bool): If True, wait for step to complete\n\nReturns:\n    None\n\nExample:\n    >>> stepper.backward_step()"
          },
          {
            "name": "move_by_acceleration",
            "signature": "(self, acceleration: int, allow_reverse: bool = True) -> dict[str, int]",
            "doc": "Move by acceleration control (speed controlled via acceleration).\n\nAdvanced mode where speed is controlled by applying acceleration or\ndeceleration. Positive acceleration = accelerate forward to max speed.\nNegative acceleration = decelerate (or reverse if allow_reverse=True).\n\nArgs:\n    acceleration (int): Acceleration to apply (steps/second\u00b2)\n    allow_reverse (bool): Allow motor to reverse direction\n\nReturns:\n    dict[str, int]: Dictionary with acceleration-controlled move result.\n    Contains:\n    {\n        \"result_code\": int,      # MoveResultCode (0 = success)\n        \"acceleration\": int,     # Requested acceleration value\n        \"blocking\": int,         # 1 if blocking, 0 if non-blocking\n        \"success\": int           # 1 if result_code == 0 else 0\n    }\n\n\nExample:\n    >>> stepper.move_by_acceleration(1000)  # Accelerate forward\n    >>> stepper.move_by_acceleration(-500)  # Decelerate"
          },
          {
            "name": "stop_move",
            "signature": "(self) -> None",
            "doc": "Stop motor with normal deceleration.\n\nInitiates smooth stop using configured acceleration. Motor will\ndecelerate to zero. Safe to call from interrupt.\n\nArgs:\n    None\n\nReturns:\n    None\n\nExample:\n    >>> stepper.stop_move()"
          },
          {
            "name": "is_stopping",
            "signature": "(self) -> bool",
            "doc": "Check if motor is decelerating to stop.\n\nReturns True while motor is decelerating after stopMove() call.\n\nArgs:\n    None\n\nReturns:\n    bool: True if decelerating\n\nExample:\n    >>> if stepper.is_stopping():\n    ...     print(\"Motor is slowing down\")"
          },
          {
            "name": "force_stop",
            "signature": "(self) -> None",
            "doc": "Stop motor immediately without deceleration.\n\nAbruptly halts motor. Position may be lost due to queue flush.\nSafe to call from interrupt. Motor stops within ~20ms.\n\nArgs:\n    None\n\nReturns:\n    None\n\nExample:\n    >>> stepper.force_stop()"
          },
          {
            "name": "force_stop_and_new_position",
            "signature": "(self, new_pos: int) -> None",
            "doc": "Stop immediately and set new position.\n\nAbruptly stops motor and updates internal position counter.\nUsed when external sensor provides new position.\n\nArgs:\n    new_pos (int): New position value to set\n\nReturns:\n    None\n\nExample:\n    >>> stepper.force_stop_and_new_position(0)"
          },
          {
            "name": "steps_to_stop",
            "signature": "(self) -> int",
            "doc": "Get steps needed to decelerate to stop.\n\nCalculates how many more steps the motor will take before reaching\nzero speed if stopMove() is called now. Useful for obstacle avoidance.\n\nArgs:\n    None\n\nReturns:\n    int: Number of steps to stop\n\nExample:\n    >>> remaining = stepper.steps_to_stop()\n    >>> if stepper.get_current_position() + remaining > limit:\n    ...     stepper.stop_move()"
          },
          {
            "name": "get_current_position",
            "signature": "(self) -> int",
            "doc": "Get current motor position.\n\nReturns the internal position counter reflecting executed steps.\n\nArgs:\n    None\n\nReturns:\n    int: Current position in steps\n\nExample:\n    >>> pos = stepper.get_current_position()"
          },
          {
            "name": "get_target_position",
            "signature": "(self) -> int",
            "doc": "Get target position for current move.\n\nReturns the position the motor is moving toward.\n\nArgs:\n    None\n\nReturns:\n    int: Target position in steps\n\nExample:\n    >>> target = stepper.get_target_position()"
          },
          {
            "name": "set_current_position",
            "signature": "(self, position: int) -> None",
            "doc": "Manually set the current position.\n\nChanges the motor's internal position counter to the specified value.\nUseful for calibration or when using external position feedback sensors.\nRecommend using only while motor is stopped.\n\nArgs:\n    position (int): New position value\n\nReturns:\n    None\n\nExample:\n    >>> stepper.set_current_position(0)  # Reset to origin"
          },
          {
            "name": "distance_to_go",
            "signature": "(self) -> int",
            "doc": "Get remaining distance to target position.\n\nReturns the number of steps between current position and target position.\nPositive means target is ahead, negative means behind.\n\nArgs:\n    None\n\nReturns:\n    int: Steps remaining (can be negative)\n\nExample:\n    >>> remaining = stepper.distance_to_go()\n    >>> if remaining == 0:\n    ...     print(\"Motor reached target\")"
          },
          {
            "name": "is_running",
            "signature": "(self) -> bool",
            "doc": "Check if motor is currently moving.\n\nReturns True while the motor has commanded position different from\ncurrent position and is executing steps. Returns False when idle.\nEssential for non-blocking operation.\n\nArgs:\n    None\n\nReturns:\n    bool: True if motor is moving, False if idle\n\nExample:\n    >>> stepper.move_to(5000)\n    >>> while stepper.is_running():\n    ...     # Do other work while motor moves\n    ...     pass"
          },
          {
            "name": "ticks_in_queue",
            "signature": "(self) -> int",
            "doc": "Get number of CPU ticks queued for execution.\n\nReturns the cumulative ticks queued for future execution. Useful for\nmonitoring queue depth and ensuring sufficient lookahead for smooth motion.\n\nArgs:\n    None\n\nReturns:\n    int: Number of ticks in command queue\n\nExample:\n    >>> queue_ticks = stepper.ticks_in_queue()"
          },
          {
            "name": "has_ticks_in_queue",
            "signature": "(self, min_ticks: int) -> bool",
            "doc": "Check if command queue has minimum ticks pending.\n\nReturns True if there are at least min_ticks queued for future execution.\n\nArgs:\n    min_ticks (int): Minimum ticks to check for\n\nReturns:\n    bool: True if queue has at least min_ticks pending\n\nExample:\n    >>> if stepper.has_ticks_in_queue(1000):\n    ...     print(\"Queue is well-stocked\")"
          },
          {
            "name": "queue_entries",
            "signature": "(self) -> int",
            "doc": "Get number of command queue entries in use.\n\nReturns the count of command entries currently in the queue.\nEach command can contain multiple steps. Queue depth varies by platform\n(typically 16-32 entries).\n\nArgs:\n    None\n\nReturns:\n    int: Number of queue entries in use\n\nExample:\n    >>> entries = stepper.queue_entries()"
          },
          {
            "name": "get_period_after_commands_us",
            "signature": "(self) -> int",
            "doc": "Get time in microseconds until queue completion.\n\nReturns the estimated time needed to execute all queued commands.\nUseful for synchronizing with other tasks or scheduling the next\nmovement command.\n\nArgs:\n    None\n\nReturns:\n    int: Time in microseconds until queue is empty\n\nExample:\n    >>> wait_time_us = stepper.get_period_after_commands_us()"
          },
          {
            "name": "get_period_after_commands_ticks",
            "signature": "(self) -> int",
            "doc": "Get time in CPU ticks until queue completion.\n\nReturns the estimated time needed to execute all queued commands,\nexpressed in CPU ticks.\n\nArgs:\n    None\n\nReturns:\n    int: Time in CPU ticks until queue is empty\n\nExample:\n    >>> wait_time_ticks = stepper.get_period_after_commands_ticks()"
          },
          {
            "name": "get_position_after_commands_completed",
            "signature": "(self) -> int",
            "doc": "Get position after all queued commands complete.\n\nReturns where the motor will be positioned after executing all\ncurrently queued commands.\n\nArgs:\n    None\n\nReturns:\n    int: Future position in steps\n\nExample:\n    >>> future_pos = stepper.get_position_after_commands_completed()"
          },
          {
            "name": "set_position_after_commands_completed",
            "signature": "(self, new_pos: int) -> None",
            "doc": "Set future position after queued commands complete.\n\nUpdates the internal position that will be set after current command\nqueue drains. Takes immediate effect on getCurrentPosition().\n\nArgs:\n    new_pos (int): Position value to set after queue completes\n\nReturns:\n    None\n\nExample:\n    >>> stepper.set_position_after_commands_completed(0)"
          },
          {
            "name": "ramp_state",
            "signature": "(self) -> int",
            "doc": "Get current ramp generator state.\n\nReturns state flags indicating current ramp state and direction.\nAdvanced users only.\n\nArgs:\n    None\n\nReturns:\n    int: State flags (RAMP_STATE_... and RAMP_DIRECTION_... combined)\n\nExample:\n    >>> state = stepper.ramp_state()"
          },
          {
            "name": "is_ramp_generator_active",
            "signature": "(self) -> bool",
            "doc": "Check if ramp generator is active.\n\nReturns True while acceleration/deceleration is being calculated.\n\nArgs:\n    None\n\nReturns:\n    bool: True if ramp generator is running\n\nExample:\n    >>> if stepper.is_ramp_generator_active():\n    ...     print(\"Motor is accelerating/decelerating\")"
          },
          {
            "name": "enable_outputs",
            "signature": "(self) -> bool",
            "doc": "Enable motor driver outputs.\n\nEnergizes the motor, allowing it to hold torque. Used with manual\nenable control (when auto_enable is False).\n\nArgs:\n    None\n\nReturns:\n    bool: True if successfully enabled\n\nExample:\n    >>> stepper.enable_outputs()"
          },
          {
            "name": "disable_outputs",
            "signature": "(self) -> bool",
            "doc": "Disable motor driver outputs.\n\nDe-energizes the motor, reducing power consumption. Motor loses holding\ntorque but can still be rotated manually. Used with manual enable control.\n\nArgs:\n    None\n\nReturns:\n    bool: True if successfully disabled\n\nExample:\n    >>> stepper.disable_outputs()"
          },
          {
            "name": "set_forward_planning_time_ms",
            "signature": "(self, ms: int) -> None",
            "doc": "Configure forward planning horizon (advanced users only).\n\nSets how far ahead the acceleration planner looks. Longer horizon provides\nsmoother acceleration curves but increases latency to speed changes.\nDefault is 20ms. Only change if stepper is not running.\n\nAttention: This is for advanced users only. Too small values risk the\nstepper running at full speed then stopping abruptly due to queue underrun.\n\nArgs:\n    ms (int): Planning horizon in milliseconds\n\nReturns:\n    None\n\nExample:\n    >>> stepper.set_forward_planning_time_ms(30)"
          },
          {
            "name": "detach_from_pin",
            "signature": "(self) -> None",
            "doc": "Detach stepper from its pin (advanced).\n\nReleases the step pin for other use. Pretty low-level, use with care.\n\nArgs:\n    None\n\nReturns:\n    None\n\nExample:\n    >>> stepper.detach_from_pin()"
          },
          {
            "name": "reattach_to_pin",
            "signature": "(self) -> None",
            "doc": "Reattach stepper to its pin (advanced).\n\nRestores stepper control after detachFromPin(). Pretty low-level, use with care.\n\nArgs:\n    None\n\nReturns:\n    None\n\nExample:\n    >>> stepper.reattach_to_pin()"
          },
          {
            "name": "attach_to_pulse_counter",
            "signature": "(self, unused_pcnt_unit: int = 0, low_value: int = -16384, high_value: int = 16384) -> bool",
            "doc": "Attach stepper to pulse counter for position verification (ESP32 only, advanced).\n\nConnects an independent pulse counter to track steps and verify\ncorrect execution. Used for testing and quality assurance.\n\nNote: The pcnt_unit parameter is ignored on IDF5; units are managed by the system.\n\nArgs:\n    unused_pcnt_unit (int): Pulse counter unit (ignored on IDF5, for compatibility)\n    low_value (int): Low counter limit (default -16384)\n    high_value (int): High counter limit (default 16384)\n    dir_pin_readback (int): Optional direction pin for readback\n\nReturns:\n    bool: True on success, False on error\n\nExample:\n    >>> stepper.attach_to_pulse_counter()\n    >>> stepper.attach_to_pulse_counter(low_value=-3200, high_value=3200)"
          },
          {
            "name": "read_pulse_counter",
            "signature": "(self) -> int",
            "doc": "Read current pulse counter value (ESP32 only).\n\nReturns the current value of the attached pulse counter.\n\nArgs:\n    None\n\nReturns:\n    int: Current pulse counter value\n\nExample:\n    >>> count = stepper.read_pulse_counter()"
          },
          {
            "name": "clear_pulse_counter",
            "signature": "(self) -> None",
            "doc": "Clear pulse counter to zero (ESP32 only).\n\nResets the pulse counter to 0.\n\nArgs:\n    None\n\nReturns:\n    None\n\nExample:\n    >>> stepper.clear_pulse_counter()"
          },
          {
            "name": "pulse_counter_attached",
            "signature": "(self) -> bool",
            "doc": "Check if pulse counter is attached (ESP32 only).\n\nReturns True if a pulse counter is currently attached.\n\nArgs:\n    None\n\nReturns:\n    bool: True if pulse counter attached\n\nExample:\n    >>> if stepper.pulse_counter_attached():\n    ...     print(\"Pulse counter is active\")"
          }
        ]
      }
    ],
    "variables": []
  },
  "comms.async_webserver": {
    "doc": "Async Web Server Stubs for ESP32 / ESP8266\n==========================================\n\nThis module provides Python-style stubs for the **ESPAsyncWebServer** library, \nenabling non-blocking, event-driven HTTP handling in Arduino-compatible \nfirmware for ESP32 and ESP8266 boards.\n\nThese classes are designed to mirror the underlying C++ APIs used in the \n`ESPAsyncWebServer` ecosystem, allowing the Python-to-Arduino transpiler \nto generate valid C++ code for asynchronous networking tasks such as \nserving files, handling REST endpoints, and implementing real-time dashboards.\n\nSupported platforms:\n    - **ESP32** (uses AsyncTCP backend)\n    - **ESP8266** (uses ESPAsyncTCP backend)\n\nMain Components:\n----------------\n- **AsyncWebServer** \u2014 main HTTP server class for route registration and startup.\n- **AsyncWebServerRequest** \u2014 represents a client request, used to read parameters and send responses.\n- **AsyncWebHandler** \u2014 abstract base for custom or callback-based request handlers.\n- **AsyncStaticWebHandler** \u2014 serves files directly from the filesystem (SPIFFS, LittleFS, etc.).\n\nExample\n-------\n```python\nimport comms.async_webserver as aw\n\nserver = aw.AsyncWebServer(80)\n\ndef handle_root(request: aw.AsyncWebServerRequest) -> None:\n    request.send(200, \"text/plain\", \"Hello from ESP!\")\n\ndef handle_about(request: aw.AsyncWebServerRequest) -> None:\n    html = \"<html><body><h1>About</h1><p>We are alrite!.</p></body></html>\"\n    request.send(200, \"text/html\", html)\n\ndef setup() -> None:\n    # Register route and start server\n    server.on(\"/\", \"HTTP_GET\", handle_root)\n    server.on(\"/about\", \"HTTP_GET\", handle_about)\n    server.begin()\n\n    # Serve static files from filesystem\n    static_page = server.serve_static(\"/files\", \"/\")\n    static_page.set_default_file(\"index.html\")\n    static_page.set_cache_control(86400)\n    static_page.set_last_modified(1700000000)\n\ndef loop() -> None:\n    # No blocking code needed \u2014 server runs asynchronously\n    pass\n\n```",
    "functions": [],
    "classes": [
      {
        "name": "AsyncWebServerRequest",
        "doc": "No docstring available",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "doc": "    Initializes a new instance of the asynchronous HTTP server.\n\nThis constructor creates an `AsyncWebServer` object bound to a specific\nnetwork port. Once instantiated, you can register HTTP route handlers\nusing the `on()` method and start the server with `begin()`.\n\nThis class serves as a Python stub for the C++ `AsyncWebServer` class from\nthe **ESPAsyncWebServer** library, commonly used on ESP32 and ESP8266 boards.\nThe actual implementation is handled by the corresponding C++ library when\nthe transpiler generates the final firmware code.\n\n**Usage Example (Python \u2192 Arduino Transpilation):**\n    ```python\n    import async_webserver as a\n\n    server = a.AsyncWebServer(80)\n\n    def handle_root(request:a.AsyncWebServerRequest) -> None:\n        request.send(200, \"text/plain\", \"Hello from ESP!\")\n\n\n    def setup()->None:\n        server.on(\"/\", HTTP_GET, handle_root)\n        server.begin()\n\n\n    def loop()->None:\n        pass\n    ```\n\n\nArgs:\n    port (int):\n        The TCP port number on which the HTTP server will listen.\n        Typically, 80 is used for standard HTTP and 443 for HTTPS.\nReturns:\n    None"
          },
          {
            "name": "send",
            "signature": "(self, status_code: int, content_type: str, body: str) -> None",
            "doc": "Sends a response to the HTTP client.\n\nArgs:\n    status_code (int): HTTP status code (e.g., 200, 404).\n    content_type (str): MIME type of the response (e.g., \"text/html\").\n    body (str): Response body content.\n\nReturns:\n    None"
          },
          {
            "name": "arg",
            "signature": "(self, name: str) -> str",
            "doc": "Gets the value of a URL parameter or POST argument by name.\n\nArgs:\n    name (str): Name of the argument to retrieve.\n\nReturns:\n    str: Value of the argument or empty string if not found."
          },
          {
            "name": "has_param",
            "signature": "(self, name: str) -> bool",
            "doc": "Checks if a given parameter exists in the request.\n\nArgs:\n    name (str): Name of the parameter.\n\nReturns:\n    bool: True if parameter exists, False otherwise."
          }
        ]
      },
      {
        "name": "AsyncWebHandler",
        "doc": "Python representation of the C++ `AsyncWebHandler` class from ESPAsyncWebServer.\n\nThis class acts as an abstract base for web request handlers such as\n`AsyncStaticWebHandler` or `AsyncCallbackWebHandler`.\n\nIt provides methods for:\n  - Determining whether a handler can process a given request.\n  - Executing the request handler.\n  - Applying authentication and filters.\n  - Controlling handler priority and behavior.\n\nNote:\n    This class should generally not be instantiated directly.\n    Instead, use subclasses that implement `can_handle()` and `handle_request()`.",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "doc": "Initialize an AsyncWebHandler instance.\n\nThis constructor sets `__use_as_is__` to False,\nmeaning the transpiler should not instantiate this class directly."
          },
          {
            "name": "can_handle",
            "signature": "(self, request: AsyncWebServerRequest) -> bool",
            "doc": "Determine whether this handler can process the incoming request.\n\nArgs:\n    request (AsyncWebServerRequest): The HTTP request object.\n\nReturns:\n    bool: True if the handler can handle the request; False otherwise.\n\nTranslation:\n    {self}.canHandle({1})"
          },
          {
            "name": "handle_request",
            "signature": "(self, request: AsyncWebServerRequest) -> None",
            "doc": "Handle the incoming web request.\n\nArgs:\n    request (AsyncWebServerRequest): The HTTP request to process.\n\nTranslation:\n    {self}.handleRequest({1})"
          },
          {
            "name": "is_request_handler_trivial",
            "signature": "(self) -> bool",
            "doc": "Check whether this handler performs trivial (lightweight) processing.\n\nReturns:\n    bool: True if the handler is trivial; False otherwise.\n\nTranslation:\n    {self}.isRequestHandlerTrivial()"
          },
          {
            "name": "set_authentication",
            "signature": "(self, username: str, password: str) -> AsyncWebHandler",
            "doc": "Protect this handler with basic authentication.\n\nArgs:\n    username (str): The HTTP Basic Auth username.\n    password (str): The HTTP Basic Auth password.\n\nReturns:\n    AsyncWebHandler: The same handler instance (for chaining).\n\nTranslation:\n    {self}.setAuthentication({1}, {2})"
          },
          {
            "name": "set_filter",
            "signature": "(self, filter_func: callable[[AsyncWebServerRequest], bool]) -> AsyncWebHandler",
            "doc": "Assign a filter function that decides if this handler should process a request.\n\nArgs:\n    filter_func (ArRequestFilterFunction): The filtering function.\n\nReturns:\n    AsyncWebHandler: The same handler instance (for chaining).\n\nTranslation:\n    {self}.setFilter({1})"
          },
          {
            "name": "filter",
            "signature": "(self, request: AsyncWebServerRequest) -> bool",
            "doc": "Run the filter function associated with this handler.\n\nArgs:\n    request (AsyncWebServerRequest): The request to evaluate.\n\nReturns:\n    bool: True if the handler should process this request.\n\nTranslation:\n    {self}.filter({1})"
          }
        ]
      },
      {
        "name": "AsyncStaticWebHandler",
        "doc": "Represents a static file handler returned by `AsyncWebServer.serve_static()`.\n\nThis class allows chaining configuration methods such as\n`set_default_file()`, `set_cache_control()`, `set_last_modified()`,\nand `set_authentication()`.\n\nExample:\n    ```python\n    server.serve_static(\"/\", \"/www\", 86400)               .set_default_file(\"index.html\")               .set_authentication(\"user\", \"pass\")\n    ```",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "doc": "This class should not be instantiated directly.\n\nInstances are automatically returned when calling\n`AsyncWebServer.serve_static()`."
          },
          {
            "name": "set_default_file",
            "signature": "(self, filename: str) -> AsyncStaticWebHandler",
            "doc": "Sets the default file to serve when a directory is requested.\n\nArgs:\n    filename (str): The file name to serve by default\n        (e.g., \"index.html\").\n\nReturns:\n    AsyncStaticWebHandler: Reference to the same handler (for chaining)."
          },
          {
            "name": "set_cache_control",
            "signature": "(self, cache_seconds: int = 86400) -> AsyncStaticWebHandler",
            "doc": "Sets the cache control duration for static files.\n\nArgs:\n    cache_seconds (int): Number of seconds that the browser\n        should cache the file (e.g., 86400 for one day).\n\nReturns:\n    AsyncStaticWebHandler: Reference to the same handler (for chaining).\n\nNotes:\n    Transpiles to:\n        `.setCacheControl(\"max-age=<cache_seconds>\")`"
          },
          {
            "name": "set_last_modified",
            "signature": "(self, timestamp: int) -> AsyncStaticWebHandler",
            "doc": "Sets the 'Last-Modified' timestamp header for the served files.\n\nArgs:\n    timestamp (int): UNIX timestamp representing the last\n        modification time.\n\nReturns:\n    AsyncStaticWebHandler: Reference to the same handler (for chaining)."
          },
          {
            "name": "set_authentication",
            "signature": "(self, user: str, password: str) -> AsyncWebHandler",
            "doc": "Sets basic HTTP authentication credentials for the static route.\n\nArgs:\n    user (str): Username required to access the files.\n    password (str): Corresponding password.\n\nReturns:\n    AsyncStaticWebHandler: Reference to the same handler (for chaining)."
          }
        ]
      },
      {
        "name": "AsyncWebServer",
        "doc": "Dummy for AsyncWebServer.\n\nRepresents the HTTP server for asynchronous request handling.",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, port: int = 80)",
            "doc": "Initializes the server on a given port.\n\nArgs:\n    port (int): Port number for the HTTP server (e.g., 80)."
          },
          {
            "name": "on",
            "signature": "(self, path: str, method: str, handler: callable[[AsyncWebServerRequest], None]) -> None",
            "doc": "Registers a request handler for a specific path and method.\n\nArgs:\n    path (str): The URL path to handle.\n    method (str): HTTP method as string (e.g., \"GET\", \"POST\").\n    handler (function): Function to call when the request is received.\n\nReturns:\n    None"
          },
          {
            "name": "begin",
            "signature": "(self) -> None",
            "doc": "Starts the server. Must be called after all routes are registered.\n\nReturns:\n    None"
          },
          {
            "name": "serve_static",
            "signature": "(self, uri: str, file_path: str) -> AsyncStaticWebHandler",
            "doc": "Serves static files from the filesystem at a given URI.\n\nArgs:\n    uri (str): The URL path prefix (e.g., \"/static\").\n    path (str): The root directory in the FS.\n    cache_control (str): Cache control header value.\n\nReturns:\n    None"
          }
        ]
      }
    ],
    "variables": []
  },
  "comms.ble_simple": {
    "doc": "BLESimple\n=========\n\nA lightweight abstraction layer that simulates Bluetooth Low Energy (BLE)\noperations for both **Central** and **Peripheral** roles.\n\nThis class provides a Python-like API for creating, managing, and interacting\nwith BLE devices. It is designed to serve as a stub for generating or simulating\nBLE logic in microcontroller environments such as ESP32 or similar boards.\n\nSupported Features\n------------------\n- Initialize BLE in `central` or `peripheral` mode.\n- Start/stop advertising or scanning.\n- Connect and disconnect devices.\n- Define services and characteristics.\n- Read, write, and notify characteristic values.\n- Register callbacks for connection, disconnection, write, and notify events.\n\nExample Usage\n-------------\n```python\n# Initialize as a peripheral\nble = BLESimple(\"MyDevice\", \"peripheral\")\n\n# Inside setup()\nble.init_ble()\nble.add_service(\"1234\")\nble.add_characteristic(\"1234\", \"5678\", \"Hello\", readable=True, writable=True, notify=True)\nble.start()\n\n# Handle incoming writes\ndef on_write_handler(value: str):\n    print(\"Central wrote:\", value)\n\nble.on_write(\"5678\", on_write_handler)```",
    "functions": [],
    "classes": [
      {
        "name": "BLESimple",
        "doc": "No docstring available",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, name: str, mode: str = 'peripheral')",
            "doc": "Initialize a BLE device in either 'central' or 'peripheral' mode.\n\nArgs:\n    name (str): The name of the BLE device.\n    mode (str): 'peripheral' or 'central'."
          },
          {
            "name": "init_ble",
            "signature": "(self) -> None",
            "doc": "Custom Initializer, call this inside setup."
          },
          {
            "name": "start",
            "signature": "(self) -> None",
            "doc": "Start BLE advertising or scanning based on the mode."
          },
          {
            "name": "stop",
            "signature": "(self) -> None",
            "doc": "Stop BLE services or connections."
          },
          {
            "name": "scan",
            "signature": "(self, timeout: int) -> list[str]",
            "doc": "Scan for nearby BLE devices (central mode only).\n\nArgs:\n    timeout (int): Scan duration in seconds.\n\nReturns:\n    list[str]: List of device names or IDs."
          },
          {
            "name": "connect_to",
            "signature": "(self, name_or_uuid: str) -> bool",
            "doc": "Connect to a BLE device by name or UUID.\n\nArgs:\n    name_or_uuid (str): Target device ID.\n\nReturns:\n    bool: True if successful."
          },
          {
            "name": "disconnect",
            "signature": "(self) -> None",
            "doc": "Disconnect from any connected BLE device."
          },
          {
            "name": "is_connected",
            "signature": "(self) -> bool",
            "doc": "Check if device is currently connected.\n\nReturns:\n    bool: Connection status."
          },
          {
            "name": "add_service",
            "signature": "(self, uuid: str) -> None",
            "doc": "Define a BLE service (peripheral mode only).\n\nArgs:\n    uuid (str): UUID of the service."
          },
          {
            "name": "add_characteristic",
            "signature": "(self, service_uuid: str, uuid: str, value: str, readable: bool = True, writable: bool = False, notify: bool = False) -> None",
            "doc": "Add a characteristic to the last-defined service.\n\nArgs:\n    service_uuid: UUID of service to be added in.\n    uuid (str): UUID of the characteristic.\n    value (str): Default value.\n    readable (bool): Whether central can read.\n    writable (bool): Whether central can write.\n    notify (bool): Whether peripheral can send notify updates."
          },
          {
            "name": "read",
            "signature": "(self, uuid: str) -> str",
            "doc": "Read a characteristic value.\n\nArgs:\n    uuid (str): Characteristic UUID.\n\nReturns:\n    str: Value."
          },
          {
            "name": "write",
            "signature": "(self, uuid: str, value: str) -> None",
            "doc": "Write a value to a characteristic.\n\nArgs:\n    uuid (str): Characteristic UUID.\n    value (str): Value to write."
          },
          {
            "name": "notify",
            "signature": "(self, uuid: str, value: str) -> None",
            "doc": "Send a notification to subscribers.\n\nArgs:\n    uuid (str): Characteristic UUID.\n    value (str): Value to send."
          },
          {
            "name": "on_connect",
            "signature": "(self, callback: callable[[], None]) -> None",
            "doc": "Register a function to call on connection.\n\nArgs:\n    callback (callable): Function with **no arguments**.\n        Example:\n            def handler(): ..."
          },
          {
            "name": "on_disconnect",
            "signature": "(self, callback: callable[[], None]) -> None",
            "doc": "Register a function to call on disconnect.\n\nArgs:\n    callback (callable): Function with **no arguments**.\n        Example:\n            def handler(): ..."
          },
          {
            "name": "on_write",
            "signature": "(self, uuid: str, callback: callable[[str], None]) -> None",
            "doc": "Set a callback for write events.\n\nArgs:\n    uuid (str): Characteristic UUID.\n    callback (callable): Function that takes **one argument (str)** \u2013 the value written by central.\n        Example:\n            def handler(value: str): ..."
          },
          {
            "name": "on_notify",
            "signature": "(self, uuid: str, callback: callable[[str], None]) -> None",
            "doc": "Set a callback for notify events.\n\nArgs:\n    uuid (str): Characteristic UUID.\n    callback (callable): Function that takes **one argument (str)** \u2013 the notified value received.\n        Example:\n            def handler(value: str): ..."
          },
          {
            "name": "get_services",
            "signature": "(self) -> list[str]",
            "doc": "Return all known service UUIDs.\n\nReturns:\n    list[str]: UUIDs"
          },
          {
            "name": "get_characteristics",
            "signature": "(self, service_uuid: str) -> dict[str, str]",
            "doc": "Return characteristics under a given service.\n\nArgs:\n    service_uuid (str): Service UUID.\n\nReturns:\n    list[str]: Characteristic UUIDs."
          }
        ]
      }
    ],
    "variables": []
  },
  "comms.mqtt": {
    "doc": "No module docstring available",
    "functions": [],
    "classes": [
      {
        "name": "PubSubClient",
        "doc": "A lightweight MQTT client for Arduino (ESP32/ESP8266) supporting publish/subscribe.",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, wifi_client: WiFiClient) -> None",
            "doc": "Initialize with a WiFiClient instance.\n\nArgs:\n    wifi_client: A WiFiClient instance (TCP transport layer)"
          },
          {
            "name": "set_server",
            "signature": "(self, host: str, port: int = 1883) -> None",
            "doc": "Set the MQTT broker address and port."
          },
          {
            "name": "set_callback",
            "signature": "(self, callback_func: callable[[str, str], None]) -> None",
            "doc": "Set the callback function for received MQTT messages."
          },
          {
            "name": "connect",
            "signature": "(self, client_id: str, username: str = '', password: str = '', will_topic: str = '', will_qos: int = 0, will_retain: bool = False, will_message: str = '') -> bool",
            "doc": "Connect to the MQTT broker using PubSubClient.\n\nThis unified method replaces all connect variants:\n  - Simple connect with only `client_id`\n  - Connect with authentication\n  - Connect with a last will message (with or without auth)\n\nAll parameters are optional except `client_id`.\nThe correct underlying overload is automatically chosen\nbased on which arguments are provided.\n\nArgs:\n    client_id (str): Unique client identifier.\n    username (str, optional): MQTT username. Defaults to \"\".\n    password (str, optional): MQTT password. Defaults to \"\".\n    will_topic (str, optional): Topic for the Last Will message. Defaults to \"\".\n    will_qos (int, optional): QoS for the Last Will message. Defaults to 0.\n    will_retain (bool, optional): Retain flag for Last Will. Defaults to False.\n    will_message (str, optional): Message content for Last Will. Defaults to \"\".\n\nReturns:\n    bool: True if connection was successful, False otherwise.\n\nExamples:\n    >>> client.connect(\"esp32_1\")\n    >>> client.connect(\"esp32_2\", username=\"user\", password=\"pass\")\n    >>> client.connect(\"esp32_3\", will_topic=\"status\", will_message=\"offline\")\n    >>> client.connect(\"esp32_4\", username=\"user\", password=\"pass\",\n    ...                will_topic=\"status\", will_qos=1, will_retain=True,\n    ...                will_message=\"offline\")"
          },
          {
            "name": "publish",
            "signature": "(self, topic: str, payload: str, retained: bool = False) -> bool",
            "doc": "Publish a plain string payload to a topic."
          },
          {
            "name": "subscribe",
            "signature": "(self, topic: str, qos: int = 0) -> bool",
            "doc": "Subscribe to a topic (QoS 0)."
          },
          {
            "name": "unsubscribe",
            "signature": "(self, topic: str) -> bool",
            "doc": "Unsubscribe from a topic."
          },
          {
            "name": "connected",
            "signature": "(self) -> bool",
            "doc": "Check if still connected to the MQTT broker."
          },
          {
            "name": "disconnect",
            "signature": "(self) -> None",
            "doc": "Disconnect from the broker."
          },
          {
            "name": "loop",
            "signature": "(self) -> None",
            "doc": "Handle incoming messages and maintain connection.\nMust be called regularly in `loop()`."
          },
          {
            "name": "set_keep_alive",
            "signature": "(self, keepalive_secs: int) -> None",
            "doc": "Set MQTT keep-alive interval (seconds)."
          },
          {
            "name": "setSocketTimeout",
            "signature": "(self, timeout_secs: int) -> None",
            "doc": "Set socket timeout in seconds."
          },
          {
            "name": "set_buffer_size",
            "signature": "(self, size: int) -> None",
            "doc": "Set internal MQTT buffer size (bytes)."
          }
        ]
      }
    ],
    "variables": []
  },
  "comms.nimble_simple": {
    "doc": "No module docstring available",
    "functions": [],
    "classes": [
      {
        "name": "NimBLESimple",
        "doc": "No docstring available",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, name: str, service_uuid: str, char_uuid: str)",
            "doc": "Initialize a unified BLE peripheral on ESP32 using NimBLE.\n\nArgs:\n    name (str): Device name to advertise.\n    service_uuid (str): UUID of the primary BLE service.\n    char_uuid (str): UUID of the primary characteristic."
          },
          {
            "name": "begin",
            "signature": "(self, is_read = True, is_write = True, is_notify = True) -> None",
            "doc": "Initialize the NimBLE stack, create server/service/characteristic,\nand start advertising."
          },
          {
            "name": "stop",
            "signature": "(self) -> None",
            "doc": "Stop advertising, disconnect clients, and deinitialize BLE."
          },
          {
            "name": "send",
            "signature": "(self, data: str) -> None",
            "doc": "Send data to the connected BLE central using notification.\n\nArgs:\n    data (str): Text or binary payload to send."
          },
          {
            "name": "set_connect_callback",
            "signature": "(self, callback: callable[[str], None]) -> None",
            "doc": "No docstring available"
          },
          {
            "name": "set_disconnect_callback",
            "signature": "(self, callback: callable[[str], None]) -> None",
            "doc": "No docstring available"
          },
          {
            "name": "set_write_callback",
            "signature": "(self, callback: callable[[str], None]) -> None",
            "doc": "No docstring available"
          },
          {
            "name": "set_read_callback",
            "signature": "(self, callback: callable[[], None]) -> None",
            "doc": "No docstring available"
          },
          {
            "name": "set_notify_callback",
            "signature": "(self, callback: callable[[], None]) -> None",
            "doc": "No docstring available"
          },
          {
            "name": "is_connected",
            "signature": "(self) -> bool",
            "doc": "Check if a BLE central device is currently connected.\n\nReturns:\n    bool: True if connected, False otherwise."
          },
          {
            "name": "set_power",
            "signature": "(self, dbm: int) -> None",
            "doc": "Adjust BLE transmit power.\n\nArgs:\n    dbm (int): Power level in dBm."
          },
          {
            "name": "set_security",
            "signature": "(self, bonding: bool = True, mitm: bool = False, sc: bool = False) -> None",
            "doc": "Configure BLE security and pairing parameters.\n\nArgs:\n    bonding (bool): Enable bonding (persistent pairing).\n    mitm (bool): Require MITM protection.\n    sc (bool): Enable LE Secure Connections."
          },
          {
            "name": "get_address",
            "signature": "(self) -> str",
            "doc": "Return the ESP32\u2019s local BLE MAC address.\n\nReturns:\n    str: MAC address string."
          },
          {
            "name": "is_advertising",
            "signature": "(self) -> bool",
            "doc": "No docstring available"
          },
          {
            "name": "restart_advertising",
            "signature": "(self) -> None",
            "doc": "No docstring available"
          },
          {
            "name": "debug_state",
            "signature": "(self) -> None",
            "doc": "No docstring available"
          }
        ]
      }
    ],
    "variables": []
  },
  "comms.webserver": {
    "doc": "No module docstring available",
    "functions": [],
    "classes": [
      {
        "name": "WebServer",
        "doc": "Dummy class for ESP32/ESP8266 synchronous WebServer.\n\nThis class provides a simple HTTP server with support for GET/POST routes.\nIt is blocking and should be used for lightweight traffic only.",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, port: int = 80)",
            "doc": "Initializes the WebServer on a specified port.\n\nArgs:\n    port (int): Port number to listen on (usually 80)."
          },
          {
            "name": "on",
            "signature": "(self, path: str, method: str, handler: callable[[], None]) -> WebServer",
            "doc": "Registers a handler function for the given URL path.\n\nArgs:\n    path (str): The URL endpoint (e.g., \"/status\").\n    method (str): \"HTTP_GET\" or \"HTTP_POST\"\n    handler (callable): A function with no parameters that handles the request.\n\nExample:\n    server.on(\"/hello\", handle_hello)"
          },
          {
            "name": "begin",
            "signature": "(self) -> WebServer",
            "doc": "Starts the web server. Must be called after all routes are registered."
          },
          {
            "name": "handle_client",
            "signature": "(self) -> WebServer",
            "doc": "Processes incoming client requests. Should be called repeatedly in loop()."
          },
          {
            "name": "send",
            "signature": "(self, status_code: int, content_type: str, body: str) -> None",
            "doc": "Sends an HTTP response to the client.\n\nArgs:\n    status_code (int): HTTP status code (e.g., 200, 404).\n    content_type (str): MIME type (e.g., \"text/plain\").\n    body (str): The response body."
          },
          {
            "name": "has_arg",
            "signature": "(self, name: str) -> bool",
            "doc": "Checks if a parameter was passed in the HTTP request.\n\nArgs:\n    name (str): The name of the parameter.\n\nReturns:\n    bool: True if parameter exists, False otherwise."
          },
          {
            "name": "arg",
            "signature": "(self, name: str) -> str",
            "doc": "Retrieves the value of a parameter from the HTTP request.\n\nArgs:\n    name (str): The name of the parameter.\n\nReturns:\n    str: The value of the parameter."
          }
        ]
      }
    ],
    "variables": []
  },
  "comms.wifi": {
    "doc": "No module docstring available",
    "functions": [
      {
        "name": "wifi_begin",
        "signature": "(ssid: str, password: str) -> None",
        "doc": "No docstring available"
      },
      {
        "name": "wifi_is_connected",
        "signature": "() -> bool",
        "doc": "Checks Wi-Fi connection status.\n\nReturns:\n    bool: True if connected to Wi-Fi."
      },
      {
        "name": "wifi_localIP",
        "signature": "() -> str",
        "doc": "No docstring available"
      },
      {
        "name": "wifi_get_ip",
        "signature": "() -> str",
        "doc": "Retrieves the IP address assigned to the board.\n\nReturns:\n    str: The local IP address as a string."
      },
      {
        "name": "wifi_disconnect",
        "signature": "() -> None",
        "doc": "Disconnects from the Wi-Fi network.\n\nReturns:\n    None"
      },
      {
        "name": "scan_network",
        "signature": "() -> list[str]",
        "doc": "Scan for available WiFi networks.\n\nReturns:\n    list[str]: A list of SSIDs (network names) of nearby WiFi networks.\n\nNotes:\n    - This method will call a native function: custom_wifi_helper_scan_wifi_networks().\n    - It may block briefly while scanning completes."
      }
    ],
    "classes": [
      {
        "name": "WiFiClient",
        "doc": "A TCP client used for making WiFi-based socket connections (e.g., to MQTT/HTTP servers).",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self) -> None",
            "doc": "Initialize the client instance."
          },
          {
            "name": "connect",
            "signature": "(self, host: str, port: int) -> bool",
            "doc": "Connect to a TCP server.\n\nArgs:\n    host (str): Hostname or IP address.\n    port (int): Port number.\n\nReturns:\n    bool: True if connection succeeds."
          },
          {
            "name": "write",
            "signature": "(self, data: str) -> int",
            "doc": "Send raw data to the server.\n\nArgs:\n    data (str): Data to send.\n\nReturns:\n    int: Bytes written."
          },
          {
            "name": "print",
            "signature": "(self, data: str) -> int",
            "doc": "Print data to the stream (human-readable).\n\nArgs:\n    data (str): Data to print.\n\nReturns:\n    int: Bytes written."
          },
          {
            "name": "println",
            "signature": "(self, data: str) -> int",
            "doc": "Print data followed by newline.\n\nArgs:\n    data (str): Data to print.\n\nReturns:\n    int: Bytes written."
          },
          {
            "name": "available",
            "signature": "(self) -> int",
            "doc": "Number of bytes available to read.\n\nReturns:\n    int: Available byte count."
          },
          {
            "name": "read",
            "signature": "(self) -> int",
            "doc": "Read a single byte/char.\n\nReturns:\n    int: One byte as int."
          },
          {
            "name": "read_bytes",
            "signature": "(self, buffer: str, length: int) -> int",
            "doc": "Read a fixed number of bytes into the provided buffer.\n\nArgs:\n    buffer (str): A string variable name that acts as the target buffer in generated code.\n    length (int): Number of bytes to read.\n\nReturns:\n    int: Number of bytes read."
          },
          {
            "name": "read_string",
            "signature": "(self) -> str",
            "doc": "Read all available bytes as a string.\n\nReturns:\n    str: Entire stream as string."
          },
          {
            "name": "peek",
            "signature": "(self) -> int",
            "doc": "Peek at next byte without removing.\n\nReturns:\n    int: Next byte as int."
          },
          {
            "name": "flush",
            "signature": "(self) -> None",
            "doc": "Wait for outgoing data to be sent."
          },
          {
            "name": "stop",
            "signature": "(self) -> None",
            "doc": "Close the TCP connection."
          },
          {
            "name": "connected",
            "signature": "(self) -> bool",
            "doc": "Check if still connected to server.\n\nReturns:\n    bool: True if connected."
          }
        ]
      }
    ],
    "variables": []
  },
  "comms.wifi_manager": {
    "doc": "No module docstring available",
    "functions": [],
    "classes": [
      {
        "name": "WiFiManager",
        "doc": "A WiFi manager that auto-connects to known networks or opens a config portal for ESP32/ESP8266.",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self) -> None",
            "doc": "No docstring available"
          },
          {
            "name": "set_debug_output",
            "signature": "(self, enable: bool) -> None",
            "doc": "Enable or disable debug logging on Serial."
          },
          {
            "name": "reset_settings",
            "signature": "(self) -> None",
            "doc": "Clear stored WiFi credentials from flash."
          },
          {
            "name": "auto_connect",
            "signature": "(self, ap_name: str, ap_password: str) -> bool",
            "doc": "Connect to saved WiFi or start a config portal.\n\nArgs:\n    ap_name (str): The SSID for the access point in config mode.\n    ap_password (str): Password for the access point.\n\nReturns:\n    bool: True if WiFi connection was successful."
          },
          {
            "name": "start_config_portal",
            "signature": "(self, ap_name: str, ap_password: str) -> bool",
            "doc": "Force start the configuration portal regardless of existing WiFi credentials.\n\nArgs:\n    ap_name (str): The SSID for the access point.\n    ap_password (str): Password for the access point.\n\nReturns:\n    bool: True if WiFi connected successfully."
          },
          {
            "name": "set_timeout",
            "signature": "(self, seconds: int) -> None",
            "doc": "Set timeout for config portal to auto-exit if no connection is made."
          },
          {
            "name": "set_connect_timeout",
            "signature": "(self, seconds: int) -> None",
            "doc": "Set timeout for how long to wait for WiFi connection before failing."
          },
          {
            "name": "set_minimum_signal_quality",
            "signature": "(self, quality: int) -> None",
            "doc": "Only show WiFi networks above this signal quality (in percent)."
          }
        ]
      }
    ],
    "variables": []
  },
  "core.arduino": {
    "doc": "No module docstring available",
    "functions": [
      {
        "name": "pinMode",
        "signature": "(pin: int, mode: int) -> None",
        "doc": "Configures the specified pin to behave either as an input or an output.\n\nArgs:\n    pin (int): The number of the pin whose mode you want to set.\n    mode (int): The mode to set for the pin. Common values are:\n        - INPUT (0x0): Configures the pin as an input.\n        - OUTPUT (0x1): Configures the pin as an output.\n        - INPUT_PULLUP (0x2): Configures the pin as an input with an internal pull-up resistor.\n\nReturns:\n    None"
      },
      {
        "name": "digitalWrite",
        "signature": "(pin: int, val: int) -> None",
        "doc": "Write a HIGH or LOW value to a digital pin.\n\nArgs:\n    pin (int): The number of the digital pin to write to.\n    val (int): The value to write. Use HIGH (1) or LOW (0).\n\nReturns:\n    None"
      },
      {
        "name": "digitalRead",
        "signature": "(pin: int) -> int",
        "doc": "Reads the value from a specified digital pin, either HIGH or LOW.\n\nArgs:\n    pin (int): The number of the digital pin to read from.\n\nReturns:\n    int: The value read from the pin \u2014 HIGH (1) or LOW (0)."
      },
      {
        "name": "analogRead",
        "signature": "(pin: int) -> int",
        "doc": "Reads the value from the specified analog pin.\n\nArgs:\n    pin (int): The number of the analog pin to read from.\n\nReturns:\n    int: The analog value read from the pin, typically ranging from 0 to 1023 (10-bit ADC),\n         or up to 4095 (12-bit) on some boards like ESP32."
      },
      {
        "name": "analogWrite",
        "signature": "(pin: int, val: int) -> None",
        "doc": "Writes an analog value (PWM wave) to a pin.\n\nArgs:\n    pin (int): The number of the digital pin to write to (supports PWM).\n    val (int): The duty cycle: a value between 0 (always off) and 255 (always on) for 8-bit resolution.\n\nReturns:\n    None"
      },
      {
        "name": "delay",
        "signature": "(ms: int) -> None",
        "doc": "Pauses the program for the amount of time (in milliseconds) specified.\n\nArgs:\n    ms (int): The number of milliseconds to pause.\n\nReturns:\n    None"
      },
      {
        "name": "delayMicroseconds",
        "signature": "(us: int) -> None",
        "doc": "Pauses the program for the specified time in microseconds.\n\nArgs:\n    us (int): The number of microseconds to pause.\n\nReturns:\n    None"
      },
      {
        "name": "millis",
        "signature": "() -> int",
        "doc": "Returns the number of milliseconds since the program started running.\n\nReturns:\n    int: Elapsed time in milliseconds."
      },
      {
        "name": "micros",
        "signature": "() -> int",
        "doc": "Returns the number of microseconds since the program started running.\n\nReturns:\n    int: Elapsed time in microseconds."
      },
      {
        "name": "shiftOut",
        "signature": "(dataPin: int, clockPin: int, bitOrder: int, val: int) -> None",
        "doc": "Shifts out a byte of data one bit at a time.\n\nArgs:\n    dataPin (int): The pin on which to output each bit.\n    clockPin (int): The pin to toggle to signal each bit.\n    bitOrder (int): The order to shift bits out (e.g., MSBFIRST or LSBFIRST).\n    val (int): The byte of data to shift out.\n\nReturns:\n    None"
      },
      {
        "name": "shiftIn",
        "signature": "(dataPin: int, clockPin: int, bitOrder: int) -> int",
        "doc": "Shifts in a byte of data one bit at a time.\n\nArgs:\n    dataPin (int): The pin from which to read each bit.\n    clockPin (int): The pin to toggle to signal each bit.\n    bitOrder (int): The order to shift bits in (e.g., MSBFIRST or LSBFIRST).\n\nReturns:\n    int: The byte of data read."
      },
      {
        "name": "pulseIn",
        "signature": "(pin: int, state: int, timeout: int = 1000000) -> int",
        "doc": "Reads a pulse (either HIGH or LOW) on a pin.\n\nArgs:\n    pin (int): The pin to read the pulse from.\n    state (int): The type of pulse to read: HIGH or LOW.\n    timeout (int, optional): Timeout in microseconds (default is 1 second).\n\nReturns:\n    int: The length of the pulse in microseconds (or 0 if timeout)."
      },
      {
        "name": "tone",
        "signature": "(pin: int, frequency: int, duration: int = 0) -> None",
        "doc": "Generates a square wave of the specified frequency on a pin.\n\nArgs:\n    pin (int): The pin on which to generate the tone.\n    frequency (int): The frequency of the tone in Hz.\n    duration (int, optional): Duration of the tone in milliseconds (0 for continuous).\n\nReturns:\n    None"
      },
      {
        "name": "noTone",
        "signature": "(pin: int) -> None",
        "doc": "Stops the generation of a tone on a pin.\n\nArgs:\n    pin (int): The pin to stop the tone on.\n\nReturns:\n    None"
      },
      {
        "name": "noInterrupts",
        "signature": "() -> None",
        "doc": "Disables all interrupts on the microcontroller.\n\nThis function is typically used to ensure atomic access to shared resources\nor to prevent interruptions during critical timing-sensitive operations.\n\nReturns:\n    None"
      },
      {
        "name": "interrupts",
        "signature": "() -> None",
        "doc": "Re-enables interrupts on the microcontroller.\n\nThis should be called after `noInterrupts()` to restore normal interrupt behavior.\n\nReturns:\n    None"
      },
      {
        "name": "attachInterrupt",
        "signature": "(pin: int, ISR: callable[[], None], mode: int) -> None",
        "doc": "Attaches an interrupt to a pin, triggered on a particular mode.\n\nArgs:\n    pin (int): The pin to attach the interrupt to.\n    ISR (Callable): A function to call when the interrupt is triggered.\n    mode (int): The condition to trigger the interrupt (RISING, FALLING, or CHANGE).\n\nReturns:\n    None"
      },
      {
        "name": "detachInterrupt",
        "signature": "(pin: int) -> None",
        "doc": "Disables the interrupt for a given pin.\n\nArgs:\n    pin (int): The pin to detach the interrupt from.\n\nReturns:\n    None"
      },
      {
        "name": "math_min",
        "signature": "(a: float, b: float) -> float",
        "doc": "Returns the smaller of two values.\n\nArgs:\n    a (Any): First value.\n    b (Any): Second value.\n\nReturns:\n    Any: Smaller of the two values."
      },
      {
        "name": "math_max",
        "signature": "(a: float, b: float) -> float",
        "doc": "Returns the larger of two values.\n\nArgs:\n    a (Any): First value.\n    b (Any): Second value.\n\nReturns:\n    Any: Larger of the two values."
      },
      {
        "name": "math_abs",
        "signature": "(x: float) -> float",
        "doc": "Returns the absolute value.\n\nArgs:\n    x (float): Input value.\n\nReturns:\n    float: Absolute value of x."
      },
      {
        "name": "math_constrain",
        "signature": "(x: float, a: float, b: float) -> float",
        "doc": "Constrains a number to be within a range.\n\nArgs:\n    x (float): Value to constrain.\n    a (float): Minimum limit.\n    b (float): Maximum limit.\n\nReturns:\n    float: Constrained value."
      },
      {
        "name": "math_map",
        "signature": "(x: float, in_min: float, in_max: float, out_min: float, out_max: float) -> float",
        "doc": "Re-maps a number from one range to another.\n\nArgs:\n    x (float): Value to map.\n    in_min (float): Input range min.\n    in_max (float): Input range max.\n    out_min (float): Output range min.\n    out_max (float): Output range max.\n\nReturns:\n    float: Mapped output."
      },
      {
        "name": "math_pow",
        "signature": "(base: float, exponent: float) -> float",
        "doc": "Returns base raised to the power of exponent.\n\nArgs:\n    base (float): The base value.\n    exponent (float): The exponent.\n\nReturns:\n    float: base ** exponent."
      },
      {
        "name": "math_sqrt",
        "signature": "(x: float) -> float",
        "doc": "Returns the square root of x.\n\nArgs:\n    x (float): Input value.\n\nReturns:\n    float: Square root of x."
      },
      {
        "name": "math_sq",
        "signature": "(x: float) -> float",
        "doc": "Returns the square of x.\n\nArgs:\n    x (float): Input value.\n\nReturns:\n    float: x * x"
      },
      {
        "name": "math_sin",
        "signature": "(radians: float) -> float",
        "doc": "Computes sine of an angle in radians.\n\nArgs:\n    radians (float): Angle in radians.\n\nReturns:\n    float: sin(radians)"
      },
      {
        "name": "math_cos",
        "signature": "(radians: float) -> float",
        "doc": "Computes cosine of an angle in radians.\n\nArgs:\n    radians (float): Angle in radians.\n\nReturns:\n    float: cos(radians)"
      },
      {
        "name": "math_tan",
        "signature": "(radians: float) -> float",
        "doc": "Computes tangent of an angle in radians.\n\nArgs:\n    radians (float): Angle in radians.\n\nReturns:\n    float: tan(radians)"
      },
      {
        "name": "math_radians",
        "signature": "(degrees: float) -> float",
        "doc": "Converts degrees to radians.\n\nArgs:\n    degrees (float): Angle in degrees.\n\nReturns:\n    float: Angle in radians."
      },
      {
        "name": "math_degrees",
        "signature": "(radians: float) -> float",
        "doc": "Converts radians to degrees.\n\nArgs:\n    radians (float): Angle in radians.\n\nReturns:\n    float: Angle in degrees."
      },
      {
        "name": "math_round",
        "signature": "(x: float) -> int",
        "doc": "Rounds to the nearest integer.\n\nArgs:\n    x (float): Input value.\n\nReturns:\n    int: Rounded value."
      },
      {
        "name": "math_ceil",
        "signature": "(x: float) -> int",
        "doc": "Returns the smallest integer not less than x.\n\nArgs:\n    x (float): Input value.\n\nReturns:\n    int: Ceil value."
      },
      {
        "name": "math_floor",
        "signature": "(x: float) -> int",
        "doc": "Returns the largest integer not greater than x.\n\nArgs:\n    x (float): Input value.\n\nReturns:\n    int: Floor value."
      },
      {
        "name": "math_fmod",
        "signature": "(x: float, y: float) -> float",
        "doc": "Returns the floating-point remainder of x / y.\n\nArgs:\n    x (float): Dividend.\n    y (float): Divisor.\n\nReturns:\n    float: Remainder."
      },
      {
        "name": "math_log",
        "signature": "(x: float) -> float",
        "doc": "Returns natural logarithm (base e).\n\nArgs:\n    x (float): Input value.\n\nReturns:\n    float: ln(x)"
      },
      {
        "name": "math_log10",
        "signature": "(x: float) -> float",
        "doc": "Returns base-10 logarithm.\n\nArgs:\n    x (float): Input value.\n\nReturns:\n    float: log\u2081\u2080(x)"
      },
      {
        "name": "math_exp",
        "signature": "(x: float) -> float",
        "doc": "Returns e raised to the power of x.\n\nArgs:\n    x (float): Input value.\n\nReturns:\n    float: e^x"
      },
      {
        "name": "serial_begin",
        "signature": "(baudrate: int) -> None",
        "doc": "Sets the data rate in bits per second (baud) for serial data transmission.\n\nArgs:\n    baudrate (int): The baud rate (e.g., 9600, 115200)\n\nReturns:\n    None"
      },
      {
        "name": "serial_end",
        "signature": "() -> None",
        "doc": "Disables serial communication and releases the TX/RX pins.\n\nReturns:\n    None"
      },
      {
        "name": "serial_available",
        "signature": "() -> int",
        "doc": "Returns the number of bytes available for reading from the serial buffer.\n\nReturns:\n    int: Number of bytes available to read."
      },
      {
        "name": "serial_read",
        "signature": "() -> int",
        "doc": "Reads incoming serial data.\n\nReturns:\n    int: The first byte of incoming serial data, or -1 if no data is available."
      },
      {
        "name": "serial_peek",
        "signature": "() -> int",
        "doc": "Returns the next byte of incoming serial data without removing it from the internal buffer.\n\nReturns:\n    int: Next byte of incoming serial data, or -1 if no data is available."
      },
      {
        "name": "serial_flush",
        "signature": "() -> None",
        "doc": "Waits for the transmission of outgoing serial data to complete.\n\nReturns:\n    None"
      },
      {
        "name": "serial_print",
        "signature": "(data: str) -> None",
        "doc": "Prints data to the serial port as human-readable ASCII text.\n\nArgs:\n    data (str): The data to send.\n\nReturns:\n    None"
      },
      {
        "name": "serial_println",
        "signature": "(data: str) -> None",
        "doc": "Prints data to the serial port followed by a newline character.\n\nArgs:\n    data (str): The data to send.\n\nReturns:\n    None"
      },
      {
        "name": "arduino_bit",
        "signature": "(n: int) -> int",
        "doc": "Returns a value with a single bit set.\n\nArgs:\n    n (int): Bit position (0 = least significant bit).\n\nReturns:\n    int: A value with the nth bit set (1 << n)."
      },
      {
        "name": "arduino_bitRead",
        "signature": "(value: int, bit: int) -> int",
        "doc": "Reads a specific bit from a value.\n\nArgs:\n    value (int): The input integer.\n    bit (int): Bit position to read.\n\nReturns:\n    int: 0 or 1, the value of the bit at the given position."
      },
      {
        "name": "arduino_bitSet",
        "signature": "(value: int, bit: int) -> int",
        "doc": "Sets a specific bit in a value.\n\nArgs:\n    value (int): The input integer.\n    bit (int): Bit position to set.\n\nReturns:\n    int: Modified value with bit set."
      },
      {
        "name": "arduino_bitClear",
        "signature": "(value: int, bit: int) -> int",
        "doc": "Clears a specific bit in a value.\n\nArgs:\n    value (int): The input integer.\n    bit (int): Bit position to clear.\n\nReturns:\n    int: Modified value with bit cleared."
      },
      {
        "name": "arduino_bitWrite",
        "signature": "(value: int, bit: int, bitvalue: int) -> int",
        "doc": "Writes a 0 or 1 to a specific bit position in a value.\n\nArgs:\n    value (int): The input integer.\n    bit (int): Bit position to write to.\n    bitvalue (int): Either 0 (clear bit) or 1 (set bit).\n\nReturns:\n    int: Modified value."
      },
      {
        "name": "arduino_lowByte",
        "signature": "(val: int) -> int",
        "doc": "Returns the low byte (least significant 8 bits) of a 16-bit value.\n\nArgs:\n    val (int): A 16-bit integer.\n\nReturns:\n    int: The lower 8 bits of the input value."
      },
      {
        "name": "arduino_highByte",
        "signature": "(val: int) -> int",
        "doc": "Returns the high byte (most significant 8 bits) of a 16-bit value.\n\nArgs:\n    val (int): A 16-bit integer.\n\nReturns:\n    int: The upper 8 bits of the input value."
      },
      {
        "name": "arduino_random",
        "signature": "(min_val: int, max_val: int) -> int",
        "doc": "Generates a random integer between min_val (inclusive) and max_val (exclusive).\n\nArgs:\n    min_val (int): Minimum value (inclusive).\n    max_val (int): Maximum value (exclusive).\n\nReturns:\n    int: A random integer in the given range."
      },
      {
        "name": "arduino_randomSeed",
        "signature": "(seed: int) -> None",
        "doc": "Seeds the random number generator with a given seed.\n\nArgs:\n    seed (int): The seed value.\n\nReturns:\n    None"
      }
    ],
    "classes": [],
    "variables": []
  },
  "core.env_vars": {
    "doc": "No module docstring available",
    "functions": [
      {
        "name": "get_env_var",
        "signature": "(var_name: str) -> str",
        "doc": "No docstring available"
      }
    ],
    "classes": [],
    "variables": []
  },
  "peripherals.esp_camera": {
    "doc": "ESP32 Camera Peripheral\n=======================\n\nThis module provides a Python-style abstraction for the **ESP32 Camera Peripheral**, \nenabling you to easily capture photos, stream video, and upload images via HTTP.  \nIt wraps Espressif\u2019s low-level `esp_camera` driver and provides high-level access \nthrough the `Camera` and `Image` classes.\n\n**Features**\n- Initialize and configure ESP32 camera (OV2640 and compatible modules)\n- Capture still frames and save locally or upload via HTTP\n- Convert captured images to Base64 (for MQTT/JSON payloads)\n- Start an HTTP MJPEG stream server\n- Automatically manage PSRAM usage and frame buffers\n\n**Dependencies**\n- ESP32 Arduino Core (`esp_camera.h`, `WiFi.h`, `HTTPClient.h`)\n- Internal helper: none (self-contained)\n- Requires hardware camera pins defined in C++ `Camera.h`\n\n**Sample Code**\n```python\nimport peripherals.camera as cam_mod\n\ncam = cam_mod.Camera(\"VGA\", \"JPEG\")\n\ndef setup() -> None:\n\n    #wifi connection is required for http.\n    while not cam.is_wifi_connected():\n        cam.wifi_connect(\"<ssid>\", \"<password>\")\n    if cam.begin():\n        img = cam.capture()\n        img.save(\"/photo.jpg\")\n        cam.send_http(\"http://example.com/upload\")\n\ndef loop() -> None:\n    pass\n```",
    "functions": [],
    "classes": [
      {
        "name": "Image",
        "doc": "Represents a captured image frame from the ESP32 camera.\nProvides convenient methods to save, encode, and inspect the image.",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self) -> None",
            "doc": "Creates an empty image container.\n\nNormally returned by `Camera.capture()`."
          },
          {
            "name": "save",
            "signature": "(self, path: str) -> None",
            "doc": "Save the captured image to SPIFFS or SD card.\n\nArgs:\n    path (str): File path, e.g. \"/photo.jpg\""
          },
          {
            "name": "base64",
            "signature": "(self) -> str",
            "doc": "Convert image data to Base64-encoded string.\n\nReturns:\n    str: Base64-encoded representation of the image"
          },
          {
            "name": "size",
            "signature": "(self) -> int",
            "doc": "Get image size in bytes.\n\nReturns:\n    int: Image size"
          },
          {
            "name": "get_width",
            "signature": "(self) -> int",
            "doc": "Get image width in pixels.\n\nReturns:\n    int: Width"
          },
          {
            "name": "get_height",
            "signature": "(self) -> int",
            "doc": "Get image height in pixels.\n\nReturns:\n    int: Height"
          }
        ]
      },
      {
        "name": "Camera",
        "doc": "Provides a Pythonic interface to initialize, capture, stream, and upload\nframes from the ESP32 camera module.",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, resolution: str = 'VGA', format: str = 'JPEG') -> None",
            "doc": "Create a new Camera instance for the ESP32-CAM module.\n\nThis constructor sets up the desired **frame resolution** and **pixel format**\nfor image capture. It does not initialize the hardware yet \u2014 call\n`begin()` or `begin_custom()` afterward to configure GPIOs and start\nthe camera driver.\n\nArgs:\n    resolution (str, optional):\n        Output frame size (image resolution).\n        Supported values (from smallest to largest):\n\n        - `\"QQVGA\"` \u2014 160 \u00d7 120\n        - `\"QVGA\"` \u2014 320 \u00d7 240\n        - `\"VGA\"` \u2014 640 \u00d7 480 (default)\n        - `\"SVGA\"` \u2014 800 \u00d7 600\n        - `\"XGA\"` \u2014 1024 \u00d7 768\n        - `\"SXGA\"` \u2014 1280 \u00d7 1024\n        - `\"UXGA\"` \u2014 1600 \u00d7 1200\n\n        Larger resolutions require more memory and PSRAM support.\n\n    format (str, optional):\n        Image pixel format (color encoding).\n        Supported values:\n\n        - `\"JPEG\"` \u2014 Compressed image format (default, best for transmission)\n        - `\"RGB565\"` \u2014 16-bit RGB color format\n        - `\"YUV422\"` \u2014 YUV color encoding (4:2:2 sampling)\n        - `\"GRAYSCALE\"` \u2014 Single-channel grayscale\n\n        Use `\"JPEG\"` for most use cases such as HTTP streaming or snapshots.\n\nReturns:\n    None\n\nExample:\n    ```python\n    import peripherals.camera as cam\n\n    # Create a camera for 800\u00d7600 JPEG capture\n    camera = cam.Camera(\"SVGA\", \"JPEG\")\n\n    # Create a grayscale camera for analytics\n    graycam = cam.Camera(\"QVGA\", \"GRAYSCALE\")\n    ```"
          },
          {
            "name": "wifi_connect",
            "signature": "(self, ssid: str, password: str) -> bool",
            "doc": "Connect the ESP32 to a Wi-Fi network.\n\nArgs:\n    ssid (str): Wi-Fi SSID.\n    password (str): Wi-Fi password.\n\nReturns:\n    bool: True if the connection succeeded, False otherwise."
          },
          {
            "name": "is_wifi_connected",
            "signature": "(self) -> bool",
            "doc": "Check whether the device is currently connected to Wi-Fi.\n\nReturns:\n    bool: True if Wi-Fi is connected."
          },
          {
            "name": "begin",
            "signature": "(self, variant_name: str = 'AI_THINKER') -> bool",
            "doc": "Initialize the ESP32 camera using a predefined pin configuration variant.\n\nThis method provides a simple way to start the camera by specifying\na known hardware variant name (such as `\"AI_THINKER\"`, `\"WROVER\"`, or `\"M5STACK\"`).\nInternally, the correct GPIO mappings for that board are automatically\nselected and used to configure the camera sensor and data pins.\n\nArgs:\n    variant_name (str):\n        Name of the ESP32 camera module variant.\n        Supported values include:\n          - \"AI_THINKER\"\n          - \"WROVER\"\n          - \"M5STACK\"\n\n        If the provided name does not match a known variant, the\n        default `\"AI_THINKER\"` mapping is used.\n\nReturns:\n    bool: True if the camera was initialized successfully, False otherwise.\n\nExample:\n    ```python\n    import peripherals.camera as cam\n\n    camera = cam.Camera(\"VGA\", \"JPEG\")\n    ok = camera.begin(\"AI_THINKER\")\n    if ok:\n        print(\"Camera ready!\")\n    else:\n        print(\"Camera failed to initialize.\")\n    ```"
          },
          {
            "name": "begin_custom",
            "signature": "(self, pin_pwdn: int = -1, pin_reset: int = -1, pin_xclk: int = 0, pin_sscb_sda: int = 26, pin_sscb_scl: int = 27, pin_d7: int = 35, pin_d6: int = 34, pin_d5: int = 39, pin_d4: int = 36, pin_d3: int = 21, pin_d2: int = 19, pin_d1: int = 18, pin_d0: int = 5, pin_vsync: int = 25, pin_href: int = 23, pin_pclk: int = 22) -> bool",
            "doc": "Initialize the ESP32 camera using a fully custom pin configuration.\n\nThis function exposes **every hardware pin** explicitly and can be\ncalled using keyword arguments for flexibility. All parameters are\noptional and have sensible defaults (AI Thinker layout).\n\nArgs:\n    pin_pwdn (int): Power-down control pin. Defaults to -1.\n    pin_reset (int): Reset pin. Defaults to -1.\n    pin_xclk (int): External clock pin (ESP32 \u2192 camera). Defaults to 0.\n    pin_sscb_sda (int): SCCB (I2C data). Defaults to 26.\n    pin_sscb_scl (int): SCCB (I2C clock). Defaults to 27.\n    pin_d7 (int): Pixel data bit 7 (MSB). Defaults to 35.\n    pin_d6 (int): Pixel data bit 6. Defaults to 34.\n    pin_d5 (int): Pixel data bit 5. Defaults to 39.\n    pin_d4 (int): Pixel data bit 4. Defaults to 36.\n    pin_d3 (int): Pixel data bit 3. Defaults to 21.\n    pin_d2 (int): Pixel data bit 2. Defaults to 19.\n    pin_d1 (int): Pixel data bit 1. Defaults to 18.\n    pin_d0 (int): Pixel data bit 0 (LSB). Defaults to 5.\n    pin_vsync (int): Vertical sync signal. Defaults to 25.\n    pin_href (int): Horizontal reference signal. Defaults to 23.\n    pin_pclk (int): Pixel clock signal. Defaults to 22.\n\nReturns:\n    bool: True if the camera initialized successfully, False otherwise.\n\nExample:\n    ```python\n    camera.begin_custom(\n        pin_pwdn=32,\n        pin_reset=-1,\n        pin_xclk=0,\n        pin_sscb_sda=26,\n        pin_sscb_scl=27,\n        pin_d7=35, pin_d6=34, pin_d5=39, pin_d4=36,\n        pin_d3=21, pin_d2=19, pin_d1=18, pin_d0=5,\n        pin_vsync=25, pin_href=23, pin_pclk=22\n    )\n    ```"
          },
          {
            "name": "capture",
            "signature": "(self) -> Image",
            "doc": "Capture a still image frame.\n\nReturns:\n    Image: Captured image object"
          },
          {
            "name": "send_http",
            "signature": "(self, url: str) -> bool",
            "doc": "Upload the latest captured image via HTTP POST.\n\nArgs:\n    url (str): Target HTTP endpoint\n\nReturns:\n    bool: True if upload succeeded"
          },
          {
            "name": "stream_http",
            "signature": "(self, port: int = 8080) -> None",
            "doc": "Start an MJPEG streaming server.\n\nArgs:\n    port (int): Port number for HTTP stream (default: 8080)\n\nNotes:\n    - Accessible via `http://<device_ip>:port`\n    - Stream runs indefinitely unless stopped manually"
          },
          {
            "name": "deinit",
            "signature": "(self) -> None",
            "doc": "Deinitialize and release camera resources."
          }
        ]
      }
    ],
    "variables": []
  },
  "sensors.adxl345": {
    "doc": "ADXL345 Accelerometer Module\n============================\n\nThis module provides a Python-style abstraction for the **Adafruit ADXL345** 3-axis accelerometer, \nallowing you to easily configure range, data rate, and read acceleration data in a Pythonic way.  \nIt wraps the `Adafruit_ADXL345_U` and `Adafruit_Sensor` C++ libraries, enabling usage from \ntranspiled Python code with full compatibility on ESP32/ESP8266 and other Arduino boards.\n\n**Features**\n- 3-axis acceleration measurement (X, Y, Z)\n- Configurable range: \u00b12g, \u00b14g, \u00b18g, \u00b116g\n- Adjustable data output rate\n- Access to raw register-level operations\n- Device ID and configuration helpers\n- I2C communication (default address: 0x53)\n\n**Dependencies**\n- Adafruit ADXL345 (`adafruit/Adafruit ADXL345`)\n- Adafruit Unified Sensor (`Adafruit_Sensor`)\n- Internal helper: `helpers/sensors/ADXL345Helper`\n\n**Sample Code**\n```python\nimport sensors.adxl345 as sensor_adxl\n\nadxl = sensor_adxl.ADXL345Sensor(0x53)\n\ndef setup() -> None:\n    adxl.begin(0x53)\n    adxl.set_range(2)        # \u00b18g\n    adxl.set_data_rate(10)   # Medium speed\n\ndef loop() -> None:\n    accel = adxl.read_acceleration()\n    print(f\"Acceleration: X={accel[0]}, Y={accel[1]}, Z={accel[2]}\")\n```",
    "functions": [],
    "classes": [
      {
        "name": "ADXL345Sensor",
        "doc": "ADXL345 accelerometer sensor stub using the Adafruit_ADXL345 library.\n\nThis class supports 3-axis acceleration sensing with configurable range and data rate.\n\nI2C default address: 0x53",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, id: int) -> None",
            "doc": "Create an instance of the ADXL345 sensor.\n\nArgs:\n    id (int): Identifier for the sensor. Just pick\n             a unique integer."
          },
          {
            "name": "begin",
            "signature": "(self, address: int = 83) -> bool",
            "doc": "Initializes the sensor.\n\nArgs:\n    address (int): I2C address (default is 0x53)\n\nReturns:\n    bool: True if successful, False if not"
          },
          {
            "name": "set_range",
            "signature": "(self, range_val: int = 0) -> None",
            "doc": "Set the ADXL345 sensor's measurement range.\n\nThe measurement range determines the maximum acceleration (in g) that\nthe sensor can detect on each axis. Larger ranges allow detection of\nstronger motion but reduce resolution.\n\nArgs:\n    range_val (int): Range selector value from 0\u20133, corresponding to:\n        0 \u2192 \u00b12g\n        1 \u2192 \u00b14g\n        2 \u2192 \u00b18g\n        3 \u2192 \u00b116g\n\nExample:\n    ```python\n    adxl.set_range(2)  # sets range to \u00b18g\n    ```\n\nNotes:\n    - Defaults to \u00b12g if the value is invalid.\n    - Internally maps to the Adafruit `range_t` enum."
          },
          {
            "name": "get_range",
            "signature": "(self) -> str",
            "doc": "Get current measurement range.\n\nReturns:\n    int: Current range value"
          },
          {
            "name": "set_data_rate",
            "signature": "(self, rate: int = 10) -> None",
            "doc": "Set the ADXL345 sensor's data output rate.\n\nThe data rate determines how frequently acceleration data is updated and made\navailable for reading. Higher rates improve responsiveness but increase power\nconsumption.\n\nArgs:\n    rate (int): Data rate selector value from 0\u201315, corresponding to:\n        0 \u2192 0.10 Hz\n        1 \u2192 0.20 Hz\n        2 \u2192 0.39 Hz\n        3 \u2192 0.78 Hz\n        4 \u2192 1.56 Hz\n        5 \u2192 3.13 Hz\n        6 \u2192 6.25 Hz\n        7 \u2192 12.5 Hz\n        8 \u2192 25 Hz\n        9 \u2192 50 Hz\n        10 \u2192 100 Hz\n        11 \u2192 200 Hz\n        12 \u2192 400 Hz\n        13 \u2192 800 Hz\n        14 \u2192 1600 Hz\n        15 \u2192 3200 Hz\n\nExample:\n    ```python\n    adxl.set_data_rate(10)  # sets update rate to 100 Hz\n    ```\n\nNotes:\n    - Defaults to 100 Hz if the rate value is invalid.\n    - Internally maps to the Adafruit `dataRate_t` enum."
          },
          {
            "name": "get_data_rate",
            "signature": "(self) -> str",
            "doc": "Get current data output rate.\n\nReturns:\n    int: Data rate value"
          },
          {
            "name": "read_acceleration",
            "signature": "(self) -> list[float]",
            "doc": "Reads current acceleration on all three axes.\n\nReturns:\n    list[float]: [x, y, z] in g"
          },
          {
            "name": "get_device_id",
            "signature": "(self) -> int",
            "doc": "Read the device ID (should be 0xE5).\n\nReturns:\n    int: Device ID"
          },
          {
            "name": "write_register",
            "signature": "(self, reg: int, value: int) -> None",
            "doc": "Write value to specified register.\n\nArgs:\n    reg (int): Register address\n    value (int): Value to write"
          },
          {
            "name": "read_register",
            "signature": "(self, reg: int) -> int",
            "doc": "Read value from specified register.\n\nArgs:\n    reg (int): Register address\n\nReturns:\n    int: Register value"
          },
          {
            "name": "read16",
            "signature": "(self, reg: int) -> int",
            "doc": "Read 16-bit value from specified register.\n\nArgs:\n    reg (int): Register address\n\nReturns:\n    int: 16-bit value"
          },
          {
            "name": "get_x",
            "signature": "(self) -> int",
            "doc": "Returns raw acceleration in X-axis.\n\nReturns:\n    int: Raw X value"
          },
          {
            "name": "get_y",
            "signature": "(self) -> int",
            "doc": "Returns raw acceleration in Y-axis.\n\nReturns:\n    int: Raw Y value"
          },
          {
            "name": "get_z",
            "signature": "(self) -> int",
            "doc": "Returns raw acceleration in Z-axis.\n\nReturns:\n    int: Raw Z value"
          }
        ]
      }
    ],
    "variables": []
  },
  "sensors.apds9960": {
    "doc": "No module docstring available",
    "functions": [],
    "classes": [
      {
        "name": "APDS9960Sensor",
        "doc": "No docstring available",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "doc": "Create an instance of the APDS9960 sensor.\nProvides access to color, proximity, and gesture sensing."
          },
          {
            "name": "begin",
            "signature": "(self, iTimeMS: int = 10, gain: int = 1, address: int = 57) -> bool",
            "doc": "Initialize the APDS9960 sensor.\n\nArgs:\n    iTimeMS (int): Integration time in milliseconds. Typical range is 10\u2013700 ms.\n          Default 10 ms.\n    gain (int): Analog gain value:\n        - 0 \u2192 1x gain\n        - 1 \u2192 4x gain\n        - 2 \u2192 16x gain\n        - 3 \u2192 64x gain\n        default 1(4x)\n    address (int): I2C address of the sensor (default is 0x39).\n\nReturns:\n    bool: True if initialization succeeded, False otherwise.\n\nTranslation:\n    custom_apds9960_helper_begin(sensor_instance, iTimeMS, gain, address)"
          },
          {
            "name": "set_adc_integration_time",
            "signature": "(self, time_ms: int) -> None",
            "doc": "Set color sensing integration time.\n\nArgs:\n    time_ms (int): Integration time in milliseconds."
          },
          {
            "name": "get_adc_integration_time",
            "signature": "(self) -> int",
            "doc": "Get the currently set integration time for color sensing.\n\nReturns:\n    float: Integration time in milliseconds."
          },
          {
            "name": "set_adc_gain",
            "signature": "(self, gain: int) -> None",
            "doc": "Set the APDS9960 sensor's ADC (Analog-to-Digital Converter) gain.\n\nThe ADC gain determines the sensitivity of the color sensing channel.\nHigher gains allow the sensor to detect faint light, while lower gains\nprevent saturation in bright environments.\n\nArgs:\n    gain (int): Gain selector value from 0\u20133, corresponding to:\n        0 \u2192 1\u00d7  (lowest sensitivity)\n        1 \u2192 4\u00d7\n        2 \u2192 16\u00d7\n        3 \u2192 64\u00d7 (highest sensitivity)\n\nExample:\n    ```python\n    apds.set_adc_gain(2)  # sets ADC gain to 16\u00d7\n    ```\n\nNotes:\n    - Defaults to 1\u00d7 if an invalid value is provided.\n    - Internally maps to the Adafruit `apds9960AGain_t` enum."
          },
          {
            "name": "get_adc_gain",
            "signature": "(self) -> int",
            "doc": "Get the currently set ADC gain.\n\nReturns:\n    int: Gain value."
          },
          {
            "name": "set_led",
            "signature": "(self, drive: int, boost: int) -> None",
            "doc": "Configures the infrared (IR) emitter LED drive and boost settings\nfor the APDS9960 sensor.\n\nThis method adjusts the current and boost factor that control\nthe intensity of the IR LED used for proximity and gesture\ndetection. Higher drive or boost values increase LED brightness\nand sensing range but also raise power consumption.\n\nArgs:\n    drive (int): LED drive current code (0\u20133).\n        Maps to approximate current levels as follows:\n            0 \u2192 100 mA\n            1 \u2192 50 mA\n            2 \u2192 25 mA\n            3 \u2192 12.5 mA\n\n    boost (int): LED current boost multiplier code (0\u20133).\n        Maps to effective current scaling factors:\n            0 \u2192 100%\n            1 \u2192 150%\n            2 \u2192 200%\n            3 \u2192 300%\n\nReturns:\n    None"
          },
          {
            "name": "enable_proximity",
            "signature": "(self, enable: bool = True) -> None",
            "doc": "Enable or disable the proximity sensor.\n\nArgs:\n    enable (bool): Set to True to enable."
          },
          {
            "name": "set_prox_gain",
            "signature": "(self, gain: int) -> None",
            "doc": "Set proximity sensor gain.\n\nArgs:\n    gain (int): Gain (0=1x, 1=2x, 2=4x, 3=8x)."
          },
          {
            "name": "get_prox_gain",
            "signature": "(self) -> int",
            "doc": "Retrieves the currently configured proximity gain level.\n\nReturns:\n    int: The proximity gain multiplier as a user-friendly integer\n    (1, 2, 4, or 8), representing the effective sensitivity applied\n    to the proximity sensing engine.\n\nNotes:\n    This value is returned in a human-readable form rather than a\n    raw register code, allowing users to work directly with familiar\n    gain factors used in proximity configuration."
          },
          {
            "name": "set_prox_pulse",
            "signature": "(self, pulse_len: int, pulses: int) -> None",
            "doc": "Configures the proximity sensing pulse sequence.\n\nThis sets both the duration of each IR LED pulse and the total\nnumber of pulses emitted during each proximity measurement cycle.\nLonger or more frequent pulses increase detection range but also\nraise power consumption.\n\nArgs:\n    pulse_len (int): Pulse duration code (0\u20133), mapped to\n        user-friendly time intervals:\n            0 \u2192 4 \u00b5s\n            1 \u2192 8 \u00b5s\n            2 \u2192 16 \u00b5s\n            3 \u2192 32 \u00b5s\n\n    pulses (int): Number of IR LED pulses per proximity cycle\n        (range: 0\u201363). Higher values improve sensitivity at the\n        cost of additional measurement time.\n\nReturns:\n    None\n\nNotes:\n    This method provides an intuitive interface for tuning the\n    proximity sensor\u2019s performance by combining pulse width and\n    count into a single configuration call."
          },
          {
            "name": "enable_proximity_interrupt",
            "signature": "(self) -> None",
            "doc": "Enable interrupt when proximity crosses threshold."
          },
          {
            "name": "disable_proximity_interrupt",
            "signature": "(self) -> None",
            "doc": "Disable proximity threshold interrupt."
          },
          {
            "name": "read_proximity",
            "signature": "(self) -> int",
            "doc": "Read proximity value from sensor.\n\nReturns:\n    int: Raw proximity measurement."
          },
          {
            "name": "set_proximity_interrupt_threshold",
            "signature": "(self, low: int, high: int, persistence: int = 4) -> None",
            "doc": "Configures the proximity interrupt trigger conditions.\n\nThis sets the low and high threshold values that determine\nwhen the proximity interrupt fires, along with a persistence\nvalue that controls how many consecutive readings must exceed\nthose thresholds before triggering.\n\nArgs:\n    low (int): Lower threshold (0\u2013255). The interrupt will trigger\n        when proximity values fall below this limit.\n    high (int): Upper threshold (0\u2013255). The interrupt will trigger\n        when proximity values exceed this limit.\n    persistence (int): Number of consecutive readings (0\u201315)\n        required to confirm the threshold condition before\n        generating an interrupt. Default 4.\n\nReturns:\n    None\n\nNotes:\n    Use this to avoid false triggers from transient movements\n    by setting appropriate threshold limits and persistence\n    for stable proximity event detection."
          },
          {
            "name": "get_proximity_interrupt",
            "signature": "(self) -> bool",
            "doc": "Check if a proximity interrupt was triggered.\n\nReturns:\n    bool: True if triggered."
          },
          {
            "name": "enable_gesture",
            "signature": "(self, enable: bool = True) -> None",
            "doc": "Enable gesture detection.\n\nArgs:\n    enable (bool): True to enable gesture sensing."
          },
          {
            "name": "gesture_valid",
            "signature": "(self) -> bool",
            "doc": "Check if a gesture event is available to read.\n\nReturns:\n    bool: True if a gesture is available."
          },
          {
            "name": "set_gesture_dimensions",
            "signature": "(self, dims: int) -> None",
            "doc": "Set dimensions used for gesture detection (e.g., up/down, left/right).\n\nArgs:\n    dims (int): Bitmask of axes to use."
          },
          {
            "name": "set_gesture_fifo_threshold",
            "signature": "(self, threshold: int) -> None",
            "doc": "Set FIFO level threshold for gesture recognition.\n\nArgs:\n    threshold (int): Threshold level."
          },
          {
            "name": "set_gesture_gain",
            "signature": "(self, gain: int) -> None",
            "doc": "Set gesture detection gain.\n\nArgs:\n    gain (int): Gain level."
          },
          {
            "name": "set_gesture_proximity_threshold",
            "signature": "(self, threshold: int) -> None",
            "doc": "Set gesture proximity threshold to start detecting gestures.\n\nArgs:\n    threshold (int): Proximity threshold."
          },
          {
            "name": "set_gesture_offset",
            "signature": "(self, up: int, down: int, left: int, right: int) -> None",
            "doc": "Set directional offset compensation for gesture detection.\n\nArgs:\n    up (int): Up offset.\n    down (int): Down offset.\n    left (int): Left offset.\n    right (int): Right offset."
          },
          {
            "name": "read_gesture",
            "signature": "(self) -> int",
            "doc": "Read detected gesture code.\n\nReturns:\n    int: Gesture code (e.g., up, down, left, right)."
          },
          {
            "name": "reset_counts",
            "signature": "(self) -> None",
            "doc": "Reset gesture detection internal counters."
          },
          {
            "name": "enable_color",
            "signature": "(self, enable: bool = True) -> None",
            "doc": "Enable color sensing features.\n\nArgs:\n    enable (bool): True to enable."
          },
          {
            "name": "color_data_ready",
            "signature": "(self) -> bool",
            "doc": "Check if color data is ready to read.\n\nReturns:\n    bool: True if data is ready."
          },
          {
            "name": "get_color_data",
            "signature": "(self) -> list[int]",
            "doc": "Read raw color channel values.\n\nReturns:\n    list[int]: [r, g, b, c] (red, green, blue, clear)."
          },
          {
            "name": "calculate_color_temperature",
            "signature": "(self, r: int, g: int, b: int) -> int",
            "doc": "Calculate color temperature from RGB values.\n\nArgs:\n    r (int): Red.\n    g (int): Green.\n    b (int): Blue.\n\nReturns:\n    int: Color temperature in Kelvin."
          },
          {
            "name": "calculate_lux",
            "signature": "(self, r: int, g: int, b: int) -> int",
            "doc": "Calculate lux from RGB values.\n\nArgs:\n    r (int): Red.\n    g (int): Green.\n    b (int): Blue.\n\nReturns:\n    int: Lux value."
          },
          {
            "name": "enable_color_interrupt",
            "signature": "(self) -> None",
            "doc": "Enable interrupt on color thresholds."
          },
          {
            "name": "disable_color_interrupt",
            "signature": "(self) -> None",
            "doc": "Disable color interrupt."
          },
          {
            "name": "clear_interrupt",
            "signature": "(self) -> None",
            "doc": "Clear all interrupt flags."
          },
          {
            "name": "set_int_limits",
            "signature": "(self, low: int, high: int) -> None",
            "doc": "Set lower and upper limits for interrupt triggering.\n\nArgs:\n    low (int): Lower threshold.\n    high (int): Upper threshold."
          },
          {
            "name": "enable",
            "signature": "(self, enable: bool = True) -> None",
            "doc": "Master enable or disable for the sensor.\n\nArgs:\n    enable (bool): True to turn on all functions."
          }
        ]
      }
    ],
    "variables": []
  },
  "sensors.bh1750": {
    "doc": "No module docstring available",
    "functions": [],
    "classes": [
      {
        "name": "BH1750Sensor",
        "doc": "No docstring available",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, address: int = 35)",
            "doc": "Create a BH1750 light sensor object.\n\nArgs:\n    address (int): I2C address of the sensor. Default is 0x23."
          },
          {
            "name": "begin",
            "signature": "(self, mode_index: int = 1, address: int = 35) -> bool",
            "doc": "Initialize the BH1750 sensor instance with selected measurement mode and I2C address.\n\nArgs:\n    mode_index (int): Measurement mode:\n        1 = CONTINUOUS_HIGH_RES_MODE\n        2 = CONTINUOUS_HIGH_RES_MODE_2\n        3 = CONTINUOUS_LOW_RES_MODE\n        4 = ONE_TIME_HIGH_RES_MODE\n        5 = ONE_TIME_HIGH_RES_MODE_2\n        6 = ONE_TIME_LOW_RES_MODE\n    address (int): I2C address (0x23 = 35 by default)\n\nReturns:\n    bool: True if initialization succeeded.\n\nNote:\n    Uses internal helper `bh1750_map_mode(mode_index)` to convert to BH1750::Mode."
          },
          {
            "name": "configure",
            "signature": "(self, mode: int) -> bool",
            "doc": "Configures the BH1750 sensor\u2019s measurement mode using a simple\ninteger mapping for user convenience.\n\nThis method allows selection of one of the standard BH1750\nillumination measurement modes \u2014 continuous or one-time,\nhigh- or low-resolution \u2014 through an integer input that is\ninternally translated to the correct `BH1750::Mode` enum.\n\nArgs:\n    mode (int): Integer mode selector corresponding to:\n        1 \u2192 CONTINUOUS_HIGH_RES_MODE\n        2 \u2192 CONTINUOUS_HIGH_RES_MODE_2\n        3 \u2192 CONTINUOUS_LOW_RES_MODE\n        4 \u2192 ONE_TIME_HIGH_RES_MODE\n        5 \u2192 ONE_TIME_HIGH_RES_MODE_2\n        6 \u2192 ONE_TIME_LOW_RES_MODE\n\nReturns:\n    bool: Always returns True if the configuration function\n    is invoked successfully.\n\nNotes:\n    This function simplifies mode selection by abstracting\n    enum handling, ensuring compatibility with the C++ helper\n    `configureBH1750Mode()`."
          },
          {
            "name": "set_mtreg",
            "signature": "(self, mtreg: int) -> bool",
            "doc": "Set MTreg register value for sensitivity control (31\u2013254).\n\nArgs:\n    mtreg (int): Value between 31 and 254.\n\nReturns:\n    bool: True if register was set successfully."
          },
          {
            "name": "measurement_ready",
            "signature": "(self, max_wait: bool) -> bool",
            "doc": "Check whether a measurement is ready.\n\nArgs:\n    max_wait (bool): If True, waits up to max measurement time.\n\nReturns:\n    bool: True if data is ready to read."
          },
          {
            "name": "read_light_level",
            "signature": "(self) -> float",
            "doc": "Read the measured light level in lux.\n\nReturns:\n    float: Light level in lux."
          }
        ]
      }
    ],
    "variables": []
  },
  "sensors.bme280": {
    "doc": "No module docstring available",
    "functions": [],
    "classes": [
      {
        "name": "BME280Sensor",
        "doc": "No docstring available",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self) -> None",
            "doc": "Initializes the BME280 sensor. Requires `begin()` to be called later."
          },
          {
            "name": "begin",
            "signature": "(self, address: int = 118) -> bool",
            "doc": "Initializes communication with the BME280 sensor.\n\nArgs:\n    address (int): I2C address of the sensor (usually 0x76 or 0x77).\n                   Default to 0x76\n\nReturns:\n    bool: True if sensor initialized correctly, False otherwise."
          },
          {
            "name": "read_temperature",
            "signature": "(self) -> float",
            "doc": "Reads temperature in Celsius.\n\nReturns:\n    float: Temperature in \u00b0C."
          },
          {
            "name": "read_humidity",
            "signature": "(self) -> float",
            "doc": "Reads relative humidity in %.\n\nReturns:\n    float: Humidity percentage."
          },
          {
            "name": "read_pressure",
            "signature": "(self) -> float",
            "doc": "Reads pressure in Pascals.\n\nReturns:\n    float: Atmospheric pressure in Pa."
          },
          {
            "name": "read_altitude",
            "signature": "(self, sea_level_hpa: float) -> float",
            "doc": "Calculates altitude based on current pressure and known sea level pressure.\n\nArgs:\n    sea_level_hpa (float): Known sea level pressure in hPa.\n\nReturns:\n    float: Estimated altitude in meters."
          }
        ]
      }
    ],
    "variables": []
  },
  "sensors.bmp085": {
    "doc": "No module docstring available",
    "functions": [],
    "classes": [
      {
        "name": "BMP085Sensor",
        "doc": "BMP085 pressure and temperature sensor stub using the Adafruit_BMP085_Unified library.",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self) -> None",
            "doc": "Create an instance of the BMP085 sensor."
          },
          {
            "name": "begin",
            "signature": "(self, mode: int = 3) -> bool",
            "doc": "Initialize the sensor with a specific mode.\n\nArgs:\n    mode (int): Operating mode:\n        - 0 = ULTRALOWPOWER\n        - 1 = STANDARD\n        - 2 = HIGHRES\n        - 3 = ULTRAHIGHRES (default)\n\nReturns:\n    bool: True if initialized successfully"
          },
          {
            "name": "get_temperature",
            "signature": "(self) -> float",
            "doc": "Reads temperature from the sensor.\n\nReturns:\n    float: Temperature in Celsius"
          },
          {
            "name": "get_pressure",
            "signature": "(self) -> float",
            "doc": "Reads pressure from the sensor.\n\nReturns:\n    float: Pressure in Pa"
          },
          {
            "name": "pressure_to_altitude",
            "signature": "(self, sea_level: float, atmospheric: float) -> float",
            "doc": "Converts pressure to altitude.\n\nArgs:\n    sea_level (float): Sea level pressure\n    atmospheric (float): Measured pressure\n\nReturns:\n    float: Altitude in meters"
          },
          {
            "name": "pressure_to_altitude_with_temp",
            "signature": "(self, sea_level: float, atmospheric: float, temp: float) -> float",
            "doc": "Converts pressure to altitude with temperature adjustment.\n\nArgs:\n    sea_level (float): Sea level pressure\n    atmospheric (float): Measured pressure\n    temp (float): Measured temperature\n\nReturns:\n    float: Altitude in meters"
          },
          {
            "name": "sea_level_for_altitude",
            "signature": "(self, altitude: float, atmospheric: float) -> float",
            "doc": "Calculates pressure at sea level from altitude.\n\nArgs:\n    altitude (float): Altitude in meters\n    atmospheric (float): Measured pressure\n\nReturns:\n    float: Sea level pressure"
          },
          {
            "name": "sea_level_for_altitude_with_temp",
            "signature": "(self, altitude: float, atmospheric: float, temp: float) -> float",
            "doc": "Calculates sea level pressure with temperature adjustment.\n\nArgs:\n    altitude (float): Altitude in meters\n    atmospheric (float): Measured pressure\n    temp (float): Temperature\n\nReturns:\n    float: Sea level pressure"
          },
          {
            "name": "get_event",
            "signature": "(self) -> dict[str, float]",
            "doc": "Reads a unified sensor event.\n\nReturns:\n    dict: {'pressure': float, 'temperature': float}"
          },
          {
            "name": "get_sensor_info",
            "signature": "(self) -> dict[str, str]",
            "doc": "Gets sensor metadata.\n\nReturns:\n    dict: Metadata dictionary"
          }
        ]
      }
    ],
    "variables": []
  },
  "sensors.ccs811": {
    "doc": "CCS811 Sensor Module\n====================\n\nThis module provides a Python-style abstraction for the **Adafruit CCS811 Air Quality Sensor**, \nenabling seamless integration within the transpiler framework.\n\nThe CCS811 is a digital gas sensor capable of measuring **eCO\u2082 (equivalent CO\u2082)** and \n**TVOC (Total Volatile Organic Compounds)** concentrations. It communicates via I\u00b2C \nand benefits from environmental compensation inputs (humidity and temperature) for optimal accuracy.\n\nFeatures\n--------\n- Initialize and configure the CCS811 sensor.\n- Read eCO\u2082 (ppm) and TVOC (ppb) air quality measurements.\n- Supply temperature and humidity compensation data.\n- Retrieve thermistor-based temperature readings.\n- Configure measurement frequency using drive modes.\n\nDependencies\n------------\n- Adafruit_CCS811\n- Adafruit_I2CDevice\n- adafruit/Adafruit BusIO (PlatformIO dependency)\n\nExample\n-------\n```python\nimport sensors.ccs811 as ccs\n\nsensor = ccs.CCS811Sensor()\n\ndef setup()->None:\n    sensor.begin()\n\n    while sensor.available():\n        eco2 = sensor.get_eco2()\n        tvoc = sensor.get_tvoc()\n\n\ndef loop()->None:\n    pass \n\n\n\n```",
    "functions": [],
    "classes": [
      {
        "name": "CCS811Sensor",
        "doc": "High-level Python wrapper for the Adafruit CCS811 gas sensor.\n\nProvides a convenient interface to initialize, read, and configure\nthe CCS811 air quality sensor over I\u00b2C.",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "doc": "Initialize a CCS811 sensor instance."
          },
          {
            "name": "begin",
            "signature": "(self) -> bool",
            "doc": "Initialize communication with the CCS811 sensor via I\u00b2C."
          },
          {
            "name": "available",
            "signature": "(self) -> bool",
            "doc": "Check whether new measurement data is available from the CCS811 sensor."
          },
          {
            "name": "read_data",
            "signature": "(self) -> bool",
            "doc": "Read the latest available data sample from the CCS811 sensor."
          },
          {
            "name": "get_eco2",
            "signature": "(self) -> int",
            "doc": "Retrieve the equivalent CO\u2082 (eCO\u2082) reading in parts per million (ppm)."
          },
          {
            "name": "get_tvoc",
            "signature": "(self) -> int",
            "doc": "Retrieve the Total Volatile Organic Compounds (TVOC) reading in parts per billion (ppb)."
          },
          {
            "name": "set_environmental_data",
            "signature": "(self, humidity: float, temperature: float) -> None",
            "doc": "Provide humidity (%) and temperature (\u00b0C) data for compensation."
          },
          {
            "name": "calculate_temperature",
            "signature": "(self) -> float",
            "doc": "Calculate temperature using the onboard thermistor."
          },
          {
            "name": "set_drive_mode",
            "signature": "(self, mode: int) -> None",
            "doc": "Set the sensor\u2019s drive mode (0\u20134) to define measurement frequency."
          }
        ]
      }
    ],
    "variables": []
  },
  "sensors.dht": {
    "doc": "DHT Sensor Module\n=================\n\nThis module provides a Python-style abstraction layer for **DHT11** and **DHT22** sensors,\nallowing seamless integration within the transpiler environment. It wraps the underlying\nC++ `DHT` class and its helper (`DHTHelper`), enabling temperature and humidity readings\nusing clean, intuitive Python syntax.\n\nThe transpiler automatically converts these calls to equivalent Arduino C++ code,\nlinking with the `adafruit/DHT sensor library`.\n\n**Dependencies:**\n    - adafruit/DHT sensor library\n\n**Includes:**\n    - DHT (hardware driver)\n    - helpers/sensors/DHTHelper (internal helper for combined reads)\n\nExample:\n```python\nimport sensors.dht as sensor_dht\n\ndht = sensor_dht.DHTSensor(2, \"DHT11\")\n\ndef setup() -> None:\n    dht.begin()\n\ndef loop() -> None:\n    temp = dht.read_temperature(False)\n    humidity = dht.read_humidity()\n    print(f\"Temperature is {temp}\")\n    print(f\"Humidity is {humidity}\")\n```",
    "functions": [],
    "classes": [
      {
        "name": "DHTSensor",
        "doc": "A Python-like abstraction for DHT11 and DHT22 sensors.",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, pin: int, type: str = 'DHT11') -> None",
            "doc": "Initialize the DHT sensor on a specific GPIO pin.\n\nArgs:\n    pin (int): GPIO pin connected to the sensor.\n    type (str): Type of the sensor: \"DHT11\" or \"DHT22\"."
          },
          {
            "name": "begin",
            "signature": "(self) -> None",
            "doc": "Begin communication with the sensor."
          },
          {
            "name": "read_temperature",
            "signature": "(self, is_fahrenheit: bool = False) -> float",
            "doc": "Read the temperature.\n\nArgs:\n    is_fahrenheit (bool): Whether to read in Fahrenheit.\n    Default is False\n\nReturns:\n    float: Temperature value."
          },
          {
            "name": "read_humidity",
            "signature": "(self) -> float",
            "doc": "Read the humidity percentage.\n\nReturns:\n    float: Humidity value."
          },
          {
            "name": "read",
            "signature": "(self) -> dict[str, float]",
            "doc": "Read both temperature and humidity.\n\nReturns:\n    dict: {\"temperature\": float, \"humidity\": float}"
          }
        ]
      }
    ],
    "variables": []
  },
  "sensors.ds18b20": {
    "doc": "No module docstring available",
    "functions": [],
    "classes": [
      {
        "name": "DS18B20Sensor",
        "doc": "A Python-like abstraction for DS18B20 temperature sensors using OneWire protocol.",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, onewire_pin: int) -> None",
            "doc": "Initialize the DS18B20 sensor on a specific GPIO pin.\n\nArgs:\n    pin (int): GPIO pin connected to the OneWire data line."
          },
          {
            "name": "begin",
            "signature": "(self) -> None",
            "doc": "Begin communication with the DS18B20 sensor."
          },
          {
            "name": "request_temperature",
            "signature": "(self) -> None",
            "doc": "Request temperature reading from the sensor. Must be called before read."
          },
          {
            "name": "read_temperature",
            "signature": "(self, index: int = 1) -> float",
            "doc": "Read the temperature in Celsius from a specific sensor (index-based).\n\nArgs:\n    index (int): Sensor index (useful if multiple sensors on the same bus).\n\nReturns:\n    float: Temperature in Celsius."
          }
        ]
      }
    ],
    "variables": []
  },
  "sensors.gp2y0a21yk": {
    "doc": "No module docstring available",
    "functions": [],
    "classes": [
      {
        "name": "GP2Y0A21YKSensor",
        "doc": "No docstring available",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "doc": "Infrared analog distance sensor (Sharp GP2Y0A21YK).\nanalog_pin defaults to 36 in ESP32 and A0 in ESP8266."
          },
          {
            "name": "distance",
            "signature": "(self) -> float",
            "doc": "Read and convert analog voltage to approximate distance.\n\nReturns:\n    float: Distance in centimeters."
          }
        ]
      }
    ],
    "variables": []
  },
  "sensors.mhz19": {
    "doc": "No module docstring available",
    "functions": [],
    "classes": [
      {
        "name": "MHZ19Sensor",
        "doc": "No docstring available",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, rx: int, tx: int, baud: int = 9600)",
            "doc": "Initialize the MHZ19 CO\u2082 sensor.\n\nArgs:\n    stream: A serial stream object (e.g., Serial1 or SoftwareSerial)."
          },
          {
            "name": "get_co2",
            "signature": "(self) -> int",
            "doc": "Get the measured CO\u2082 concentration.\n\nReturns:\n    int: CO\u2082 value in ppm."
          },
          {
            "name": "get_temperature",
            "signature": "(self) -> int",
            "doc": "Get the temperature reported by the sensor.\n\nReturns:\n    int: Temperature in Celsius."
          },
          {
            "name": "get_accuracy",
            "signature": "(self) -> int",
            "doc": "Get the measurement accuracy level.\n\nReturns:\n    int: Accuracy (unit depends on sensor calibration)."
          },
          {
            "name": "set_range",
            "signature": "(self, range_val: int) -> None",
            "doc": "Set the CO\u2082 measurement range of the MH-Z19 sensor.\n\nArgs:\n    range_val (int): Desired measurement range in parts per million (ppm).\n        Valid values are typically:\n            - 2000   \u2192 0\u20132000 ppm\n            - 5000   \u2192 0\u20135000 ppm\n            - 10000  \u2192 0\u201310000 ppm (only on supported models)\n\nNotes:\n    - The range is stored in the sensor\u2019s non-volatile memory.\n    - Changing the range may require recalibration.\n    - Unsupported values will be ignored or may yield invalid readings."
          },
          {
            "name": "calibrate_zero",
            "signature": "(self) -> None",
            "doc": "Calibrate sensor assuming current ambient air has 400 ppm CO\u2082."
          },
          {
            "name": "auto_calibration",
            "signature": "(self, enable: bool = True) -> None",
            "doc": "Enable or disable Automatic Baseline Calibration (ABC) mode.\n\nArgs:\n    enable (bool): True to enable ABC, False to disable."
          }
        ]
      }
    ],
    "variables": []
  },
  "sensors.mpu6050": {
    "doc": "No module docstring available",
    "functions": [],
    "classes": [
      {
        "name": "MPU6050Sensor",
        "doc": "MPU6050 Light Sensor stub using the rfetick/MPU6050_light library.\n\nThis class supports basic 6-axis motion sensing:\n- Accelerometer (\u00b12G to \u00b116G)\n- Gyroscope (\u00b1250\u00b0/s to \u00b12000\u00b0/s)\n- Optional temperature readout\n- Complementary filter for angle estimation\n\nDefault I2C address is 0x68.\nSet to 0x69 if AD0 pin is pulled high.",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self) -> None",
            "doc": "Create an instance of the MPU6050 sensor with default I2C address (0x68).\nCall `begin()` before reading data."
          },
          {
            "name": "begin",
            "signature": "(self, gyro_config_num: int, acc_config_num: int) -> int",
            "doc": "Initialize the sensor.\n\nArgs:\n    gyro_config_num (int): 0=\u00b1250, 1=\u00b1500, 2=\u00b11000, 3=\u00b12000 deg/s\n    acc_config_num (int):  0=\u00b12G, 1=\u00b14G, 2=\u00b18G, 3=\u00b116G\n\nReturns:\n    int: 0 on success, 1 on failure"
          },
          {
            "name": "update",
            "signature": "(self) -> None",
            "doc": "Reads all new data from the sensor.\nCall before using any `get*()` method."
          },
          {
            "name": "read_acceleration",
            "signature": "(self) -> list[float]",
            "doc": "Returns current acceleration readings in g (gravity units).\n\nReturns:\n    list[float]: [accX, accY, accZ] in g"
          },
          {
            "name": "read_gyro",
            "signature": "(self) -> list[float]",
            "doc": "Returns current gyroscope angular velocity in degrees/sec.\n\nReturns:\n    list[float]: [gyroX, gyroY, gyroZ] in \u00b0/s"
          },
          {
            "name": "read_angles",
            "signature": "(self) -> list[float]",
            "doc": "Returns estimated orientation angles using a complementary filter.\n\nReturns:\n    list[float]: [angleX, angleY, angleZ] in degrees"
          },
          {
            "name": "get_angle_x",
            "signature": "(self) -> float",
            "doc": "Returns orientation angle along x-axis"
          },
          {
            "name": "get_angle_y",
            "signature": "(self) -> float",
            "doc": "Returns orientation angle along y-axis"
          },
          {
            "name": "get_angle_z",
            "signature": "(self) -> float",
            "doc": "Returns orientation angle along z-axis"
          },
          {
            "name": "get_temperature",
            "signature": "(self) -> float",
            "doc": "Returns:\n    float: Temperature in \u00b0C"
          },
          {
            "name": "set_gyro_offsets",
            "signature": "(self, x: float, y: float, z: float) -> None",
            "doc": "Manually calibrate gyroscope offsets.\n\nArgs:\n    x (float): X-axis offset in \u00b0/s\n    y (float): Y-axis offset in \u00b0/s\n    z (float): Z-axis offset in \u00b0/s"
          },
          {
            "name": "set_acc_offsets",
            "signature": "(self, x: float, y: float, z: float) -> None",
            "doc": "Manually calibrate accelerometer offsets.\n\nArgs:\n    x (float): X-axis offset in g\n    y (float): Y-axis offset in g\n    z (float): Z-axis offset in g"
          },
          {
            "name": "calc_offsets",
            "signature": "(self, calc_gyro: bool = True, calc_acc: bool = True) -> None",
            "doc": "Automatically calculate gyro and/or accelerometer offsets.\nSensor must be stable during this process.\n\nArgs:\n    calc_gyro (bool): Calibrate gyroscope\n    calc_acc (bool): Calibrate accelerometer"
          },
          {
            "name": "set_filter_gyro_coef",
            "signature": "(self, coef: float) -> None",
            "doc": "Adjust the complementary filter\u2019s gyro weighting coefficient.\n\nArgs:\n    coef (float): Gyroscope weighting (0.0\u20131.0).\n        Higher values emphasize gyro data; lower values favor accelerometer data."
          },
          {
            "name": "set_filter_acc_coef",
            "signature": "(self, coef: float) -> None",
            "doc": "Adjust the complementary filter\u2019s accelerometer weighting coefficient.\n\nArgs:\n    coef (float): Accelerometer weighting (0.0\u20131.0).\n        Typically, acc_coef = 1.0 - gyro_coef."
          },
          {
            "name": "get_filter_gyro_coef",
            "signature": "(self) -> float",
            "doc": "Retrieve the current complementary filter gyroscope coefficient.\n\nReturns:\n    float: Current gyro weighting (0.0\u20131.0)."
          },
          {
            "name": "get_filter_acc_coef",
            "signature": "(self) -> float",
            "doc": "Retrieve the current complementary filter accelerometer coefficient.\n\nReturns:\n    float: Current accelerometer weighting (0.0\u20131.0)."
          },
          {
            "name": "fetch_data",
            "signature": "(self) -> None",
            "doc": "Perform a low-level data fetch directly from sensor registers.\nNormally, use `update()` instead of this."
          }
        ]
      }
    ],
    "variables": []
  },
  "sensors.mq135": {
    "doc": "No module docstring available",
    "functions": [],
    "classes": [
      {
        "name": "MQ135Sensor",
        "doc": "No docstring available",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, pin: int)",
            "doc": "Initialize the MQ135 sensor.\n\nArgs:\n    pin (int): The analog pin the MQ135 is connected to (e.g., A0 \u2192 0)"
          },
          {
            "name": "get_correction_factor",
            "signature": "(self, temperature: float, humidity: float) -> float",
            "doc": "Return correction factor based on temperature and humidity."
          },
          {
            "name": "get_resistance",
            "signature": "(self) -> float",
            "doc": "Read the raw sensor resistance."
          },
          {
            "name": "get_corrected_resistance",
            "signature": "(self, temperature: float, humidity: float) -> float",
            "doc": "Read corrected sensor resistance."
          },
          {
            "name": "get_ppm",
            "signature": "(self) -> float",
            "doc": "Return uncorrected PPM reading."
          },
          {
            "name": "get_corrected_ppm",
            "signature": "(self, temperature: float, humidity: float) -> float",
            "doc": "Return PPM reading corrected for temperature and humidity."
          },
          {
            "name": "get_rzero",
            "signature": "(self) -> float",
            "doc": "Return RZero from current reading."
          },
          {
            "name": "get_corrected_rzero",
            "signature": "(self, temperature: float, humidity: float) -> float",
            "doc": "Return corrected RZero based on temperature and humidity."
          }
        ]
      }
    ],
    "variables": []
  },
  "sensors.mq2": {
    "doc": "No module docstring available",
    "functions": [],
    "classes": [
      {
        "name": "MQ2Sensor",
        "doc": "MQ2 gas sensor abstraction using the Labay11/MQ-2-sensor-library.\n\nProvides methods for reading concentrations of LPG, CO, and Smoke.",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, pin: int)",
            "doc": "Initialize the MQ2 sensor.\n\nArgs:\n    pin (int): The analog pin connected to the sensor (e.g., A0 \u2192 0)."
          },
          {
            "name": "begin",
            "signature": "(self) -> None",
            "doc": "Initialize the MQ2 sensor hardware and calibration routines.\nMust be called before reading data."
          },
          {
            "name": "close",
            "signature": "(self) -> None",
            "doc": "Stop the MQ2 sensor and clear calibration data."
          },
          {
            "name": "read",
            "signature": "(self, debug: bool) -> list[float]",
            "doc": "Read all gas concentrations from the sensor.\n\nArgs:\n    debug (bool): If True, prints internal readings via Serial.\n\nReturns:\n    list[float]: [LPG, CO, Smoke] in ppm."
          },
          {
            "name": "read_lpg",
            "signature": "(self) -> float",
            "doc": "Read LPG concentration in ppm.\n\nReturns:\n    float: LPG concentration."
          },
          {
            "name": "read_co",
            "signature": "(self) -> float",
            "doc": "Read CO concentration in ppm.\n\nReturns:\n    float: CO concentration."
          },
          {
            "name": "read_smoke",
            "signature": "(self) -> float",
            "doc": "Read smoke concentration in ppm.\n\nReturns:\n    float: Smoke concentration."
          }
        ]
      }
    ],
    "variables": []
  },
  "sensors.sgp30": {
    "doc": "No module docstring available",
    "functions": [],
    "classes": [
      {
        "name": "SGP30Sensor",
        "doc": "No docstring available",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "doc": "Create an instance of the SGP30 gas sensor class.\n\nYou must call `.begin()` after instantiation to initialize I2C communication."
          },
          {
            "name": "begin",
            "signature": "(self) -> bool",
            "doc": "Initialize the sensor and begin I2C communication.\n\nReturns:\n    bool: True if initialization succeeded, False otherwise."
          },
          {
            "name": "is_connected",
            "signature": "(self) -> bool",
            "doc": "Check if the sensor is connected and responding over I2C.\n\nReturns:\n    bool: True if the device is found on the I2C bus."
          },
          {
            "name": "generic_reset",
            "signature": "(self) -> None",
            "doc": "Send a generic I2C reset command.\n\n\u26a0\ufe0f WARNING: This may reset *all* I2C devices that respond to general reset!\nUse with caution in multi-device setups."
          },
          {
            "name": "get_id",
            "signature": "(self) -> bool",
            "doc": "Retrieve the sensor's internal ID into the _id[6] buffer.\n\nReturns:\n    bool: True if ID was successfully read."
          },
          {
            "name": "get_feature_set",
            "signature": "(self) -> int",
            "doc": "Get the firmware feature set version.\n\nReturns:\n    int: Feature set code (e.g., 0x0020)."
          },
          {
            "name": "measure_test",
            "signature": "(self) -> bool",
            "doc": "Run a sensor self-test (may be destructive depending on firmware).\n\nReturns:\n    bool: True if test passed, False if failed."
          },
          {
            "name": "last_measurement",
            "signature": "(self) -> int",
            "doc": "Get the timestamp (in ms) of the last successful measurement.\n\nReturns:\n    int: Milliseconds since boot of last measurement."
          },
          {
            "name": "measure",
            "signature": "(self, all: bool = False) -> bool",
            "doc": "Perform a blocking measurement.\n\nArgs:\n    all (bool): If True, retrieves raw H2 and ethanol in addition to eCO2 and TVOC.\n\nReturns:\n    bool: True if measurement succeeded."
          },
          {
            "name": "request",
            "signature": "(self) -> None",
            "doc": "Request async measurement (non-blocking). Use `.read()` to get the result later."
          },
          {
            "name": "read",
            "signature": "(self) -> bool",
            "doc": "Read results from a previous async `.request()` call.\n\nReturns:\n    bool: True if data was available and read successfully."
          },
          {
            "name": "request_raw",
            "signature": "(self) -> None",
            "doc": "Request a raw gas resistance measurement. Use `.read_raw()` to collect results."
          },
          {
            "name": "read_raw",
            "signature": "(self) -> bool",
            "doc": "Read raw values (H2 and ethanol) from the sensor after `.request_raw()`.\n\nReturns:\n    bool: True if raw data was read successfully."
          },
          {
            "name": "get_tvoc",
            "signature": "(self) -> int",
            "doc": "Get the Total Volatile Organic Compounds (TVOC) reading.\n\nReturns:\n    int: TVOC value in parts per billion (ppb)."
          },
          {
            "name": "get_co2",
            "signature": "(self) -> int",
            "doc": "Get the equivalent CO2 (eCO\u2082) concentration.\n\nReturns:\n    int: CO2 concentration in parts per million (ppm)."
          },
          {
            "name": "get_h2_raw",
            "signature": "(self) -> int",
            "doc": "Get raw resistance signal related to hydrogen gas (H\u2082).\n\nReturns:\n    int: Raw ADC units (hardware specific, not in ppm)."
          },
          {
            "name": "get_ethanol_raw",
            "signature": "(self) -> int",
            "doc": "Get raw resistance signal related to ethanol.\n\nReturns:\n    int: Raw ADC units."
          },
          {
            "name": "get_h2",
            "signature": "(self) -> float",
            "doc": "Estimate H\u2082 concentration from raw values using internal calibration.\n\nReturns:\n    float: Hydrogen gas in PPM (experimental)."
          },
          {
            "name": "get_ethanol",
            "signature": "(self) -> float",
            "doc": "Estimate ethanol concentration from raw values using internal calibration.\n\nReturns:\n    float: Ethanol concentration in PPM (experimental)."
          },
          {
            "name": "set_rel_humidity",
            "signature": "(self, temperature: float, rh: float) -> float",
            "doc": "Provide environmental compensation using temperature and relative humidity.\n\nArgs:\n    temperature (float): Temperature in \u00b0C.\n    rh (float): Relative humidity (0\u2013100%).\n\nReturns:\n    float: Converted absolute humidity (g/m\u00b3)."
          },
          {
            "name": "set_abs_humidity",
            "signature": "(self, abs_humidity: float) -> None",
            "doc": "Set absolute humidity directly to improve sensor accuracy.\n\nArgs:\n    abs_humidity (float): Absolute humidity in grams per cubic meter (g/m\u00b3).\n                          Set to 0 to disable humidity compensation."
          },
          {
            "name": "set_baseline",
            "signature": "(self, co2: int, tvoc: int) -> None",
            "doc": "Set the known baseline values for eCO2 and TVOC.\n\nArgs:\n    co2 (int): Baseline CO2 in ppm.\n    tvoc (int): Baseline TVOC in ppb."
          },
          {
            "name": "get_baseline",
            "signature": "(self, co2_ptr, tvoc_ptr) -> bool",
            "doc": "Retrieve the current baseline for eCO2 and TVOC.\n\nArgs:\n    co2_ptr: Pointer or container to receive CO2 baseline.\n    tvoc_ptr: Pointer or container to receive TVOC baseline.\n\nReturns:\n    bool: True if successful."
          },
          {
            "name": "set_tvoc_baseline",
            "signature": "(self, tvoc: int) -> None",
            "doc": "Set only the TVOC baseline value.\n\nArgs:\n    tvoc (int): TVOC baseline in ppb."
          },
          {
            "name": "get_tvoc_baseline",
            "signature": "(self, tvoc_ptr) -> bool",
            "doc": "Retrieve only the TVOC baseline.\n\nArgs:\n    tvoc_ptr: Pointer or container to receive baseline.\n\nReturns:\n    bool: True if successful."
          },
          {
            "name": "set_sref_h2",
            "signature": "(self, s: int) -> None",
            "doc": "Set sensor reference value for H2 calibration (advanced use).\n\nArgs:\n    s (int): Raw average value from clean H\u2082 environment (e.g., 13119)."
          },
          {
            "name": "get_sref_h2",
            "signature": "(self) -> int",
            "doc": "Get current sensor reference value for H2 calibration.\n\nReturns:\n    int: Raw reference value."
          },
          {
            "name": "set_sref_ethanol",
            "signature": "(self, s: int) -> None",
            "doc": "Set sensor reference value for ethanol calibration (advanced use).\n\nArgs:\n    s (int): Raw average ethanol baseline value."
          },
          {
            "name": "get_sref_ethanol",
            "signature": "(self) -> int",
            "doc": "Get current reference value used for ethanol baseline calibration.\n\nReturns:\n    int: Raw baseline value."
          },
          {
            "name": "last_error",
            "signature": "(self) -> int",
            "doc": "Return last I2C or CRC error code from any operation.\n\nReturns:\n    int: 0 = OK, 0xFE = I2C error, 0xFF = CRC error."
          }
        ]
      }
    ],
    "variables": []
  },
  "sensors.sht31": {
    "doc": "No module docstring available",
    "functions": [],
    "classes": [
      {
        "name": "SHT31Sensor",
        "doc": "Wrapper for Adafruit SHT31 temperature/humidity sensor.\nUsed for Python-to-Arduino transpilation.",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self) -> None",
            "doc": "Initialize SHT31 instance.\n\nArgs:\n    address (int): I2C address of the sensor (default 0x44)"
          },
          {
            "name": "begin",
            "signature": "(self, address: int = 68) -> bool",
            "doc": "Initialize I2C communication with the sensor.\n\nReturns:\n    bool: True if sensor initialized successfully."
          },
          {
            "name": "read_temperature",
            "signature": "(self) -> float",
            "doc": "Read temperature in Celsius."
          },
          {
            "name": "read_humidity",
            "signature": "(self) -> float",
            "doc": "Read relative humidity in percentage."
          },
          {
            "name": "reset",
            "signature": "(self) -> None",
            "doc": "Soft-reset the SHT31 sensor."
          },
          {
            "name": "heater_enabled",
            "signature": "(self) -> bool",
            "doc": "Check if the internal heater is enabled."
          },
          {
            "name": "toggle_heater",
            "signature": "(self, on: bool) -> None",
            "doc": "Enable or disable the internal heater."
          }
        ]
      }
    ],
    "variables": []
  },
  "sensors.tsl2561": {
    "doc": "No module docstring available",
    "functions": [],
    "classes": [
      {
        "name": "TSL2561Sensor",
        "doc": "No docstring available",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, address: int = 57)",
            "doc": "Create a TSL2561 light sensor object.\n\nArgs:\n    address (int): I2C address of the sensor (0x29, 0x39, or 0x49)."
          },
          {
            "name": "begin",
            "signature": "(self) -> bool",
            "doc": "Initialize the sensor.\n\nReturns:\n    bool: True if initialization succeeded."
          },
          {
            "name": "enable_auto_range",
            "signature": "(self, enable: bool) -> None",
            "doc": "Enable or disable automatic gain range adjustment."
          },
          {
            "name": "set_integration_time",
            "signature": "(self, integration_mode: int) -> None",
            "doc": "Set the integration time (exposure).\n\nArgs:\n    integration_mode (int): One of:\n        0 = 13ms,\n        1 = 101ms,\n        2 = 402ms"
          },
          {
            "name": "set_gain",
            "signature": "(self, gain_mode: int) -> None",
            "doc": "Set gain mode.\n\nArgs:\n    gain_mode (int): 0 = 1x gain, 1 = 16x gain."
          },
          {
            "name": "get_luminosity",
            "signature": "(self) -> list[int]",
            "doc": "Read broadband and IR luminosity.\n\nReturns:\n    list[int, int]: (broadband, ir) values."
          },
          {
            "name": "calculate_lux",
            "signature": "(self, broadband: int, ir: int) -> int",
            "doc": "Calculate lux value from given channel readings.\n\nArgs:\n    broadband (int): Channel 0 (visible + IR).\n    ir (int): Channel 1 (IR only).\n\nReturns:\n    int: Calculated lux value."
          }
        ]
      }
    ],
    "variables": []
  },
  "sensors.ultrasonic": {
    "doc": "No module docstring available",
    "functions": [],
    "classes": [
      {
        "name": "UltrasonicSensor",
        "doc": "No docstring available",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self, trigger_pin: int, echo_pin: int, max_cm_distance: int = 500)",
            "doc": "Represents an ultrasonic distance sensor using the NewPing library.\n\nThis class supports low-level ultrasonic sensors that work via\ndigital pulse duration, specifically those with a trigger pin and\necho pin.\n\n\u2705 Supported sensor models:\n- HC-SR04\n- SRF05\n- DYP-ME007\n- Parallax PING)))\u2122 (single-pin supported)\n- SRF06 (with capacitor or dual-pin mode only)\n\n\u274c Not supported:\n- Analog sensors (e.g., Sharp GP2Y series)\n- I2C/SPI ToF sensors (e.g., VL53L0X, VL6180X)\n\nArgs:\n    trigger_pin (int): GPIO pin used to send trigger pulse.\n    echo_pin (int): GPIO pin used to receive echo pulse.\n    max_cm_distance (int, optional): Maximum measurable distance in cm. Default is 500."
          },
          {
            "name": "ping",
            "signature": "(self) -> int",
            "doc": "Send a ping and return the echo time in microseconds.\n\nReturns:\n    int: Echo duration in microseconds."
          },
          {
            "name": "ping_in",
            "signature": "(self) -> int",
            "doc": "Send a ping and return the distance in whole inches.\n\nReturns:\n    int: Distance in inches."
          },
          {
            "name": "ping_cm",
            "signature": "(self) -> int",
            "doc": "Send a ping and return the distance in whole centimeters.\n\nReturns:\n    int: Distance in centimeters."
          },
          {
            "name": "ping_median",
            "signature": "(self, iterations: int = 5) -> int",
            "doc": "Perform multiple pings and return the median echo time (in microseconds).\nHelps filter out invalid readings.\n\nArgs:\n    iterations (int): Number of pings to average. Default is 5.\n\nReturns:\n    int: Median echo time in microseconds."
          },
          {
            "name": "convert_in",
            "signature": "(self, echo_time: int) -> int",
            "doc": "Convert echo time to distance in inches.\n\nArgs:\n    echo_time (int): Echo duration in microseconds.\n\nReturns:\n    int: Distance in inches."
          },
          {
            "name": "convert_cm",
            "signature": "(self, echo_time: int) -> int",
            "doc": "Convert echo time to distance in centimeters.\n\nArgs:\n    echo_time (int): Echo duration in microseconds.\n\nReturns:\n    int: Distance in centimeters."
          }
        ]
      }
    ],
    "variables": []
  },
  "sensors.vl53l0x": {
    "doc": "No module docstring available",
    "functions": [],
    "classes": [
      {
        "name": "VL53L0XSensor",
        "doc": "No docstring available",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self)",
            "doc": "VL53L0X time-of-flight distance sensor.\nUses I2C (default address: 0x29)."
          },
          {
            "name": "begin",
            "signature": "(self, i2c_addr: int = 41, debug: bool = True) -> bool",
            "doc": "Initialize the sensor.\n\nArgs:\n    i2c_addr (int): I2C address (default 0x29).\n    debug (bool): Enable debug logging.\n\nReturns:\n    bool: True if initialization succeeded."
          },
          {
            "name": "set_address",
            "signature": "(self, new_addr: int) -> bool",
            "doc": "Set a new I2C address for the sensor.\n\nArgs:\n    new_addr (int): New address to assign.\n\nReturns:\n    bool: True if successful."
          },
          {
            "name": "read_range",
            "signature": "(self) -> int",
            "doc": "Perform a single range read.\n\nReturns:\n    int: Distance in millimeters."
          },
          {
            "name": "read_range_status",
            "signature": "(self) -> int",
            "doc": "Get status of the last range reading.\n\nReturns:\n    int: Status code (0 = OK)."
          },
          {
            "name": "start_range",
            "signature": "(self) -> bool",
            "doc": "Start a range measurement.\n\nReturns:\n    bool: True if started."
          },
          {
            "name": "is_range_complete",
            "signature": "(self) -> bool",
            "doc": "Check if the range measurement is complete.\n\nReturns:\n    bool: True if complete."
          },
          {
            "name": "wait_range_complete",
            "signature": "(self) -> bool",
            "doc": "Wait for the range to complete.\n\nReturns:\n    bool: True if completed."
          },
          {
            "name": "read_range_result",
            "signature": "(self) -> int",
            "doc": "Read the result of the last range.\n\nReturns:\n    int: Distance in millimeters."
          },
          {
            "name": "start_range_continuous",
            "signature": "(self, period_ms: int = 50) -> bool",
            "doc": "Start continuous ranging mode.\n\nArgs:\n    period_ms (int): Delay between measurements. Default 50.\n\nReturns:\n    bool: True if successful."
          },
          {
            "name": "stop_range_continuous",
            "signature": "(self) -> None",
            "doc": "Stop continuous ranging mode."
          },
          {
            "name": "timeout_occurred",
            "signature": "(self) -> bool",
            "doc": "Check if timeout occurred.\n\nReturns:\n    bool: True if timeout occurred."
          },
          {
            "name": "config_sensor",
            "signature": "(self, mode: int = 0) -> bool",
            "doc": "Configure predefined sensor mode.\n\nArgs:\n    mode (int): One of:\n        - 0 = default\n        - 1 = long range\n        - 2 = high speed\n        - 3 = high accuracy\n\nReturns:\n    bool: True if configuration successful."
          },
          {
            "name": "set_measurement_timing_budget",
            "signature": "(self, budget_us: int) -> bool",
            "doc": "Set measurement timing budget in microseconds.\n\nArgs:\n    budget_us (int): Time budget in \u00b5s.\n\nReturns:\n    bool: True if set."
          },
          {
            "name": "get_measurement_timing_budget",
            "signature": "(self) -> int",
            "doc": "Get measurement timing budget.\n\nReturns:\n    int: Time budget in \u00b5s."
          },
          {
            "name": "set_vcsel_pulse_period",
            "signature": "(self, period_type: int, pulse_period: int) -> bool",
            "doc": "Set VCSEL pulse period.\n\nArgs:\n    period_type (int): VCSEL period enum.\n    pulse_period (int): Pulse width in units.\n\nReturns:\n    bool: True if set."
          },
          {
            "name": "get_vcsel_pulse_period",
            "signature": "(self, period_type: int) -> int",
            "doc": "Get VCSEL pulse period.\n\nArgs:\n    period_type (int): VCSEL period enum.\n\nReturns:\n    int: Pulse period value."
          }
        ]
      }
    ],
    "variables": []
  },
  "storage.spiffs": {
    "doc": "No module docstring available",
    "functions": [
      {
        "name": "spiffs_begin",
        "signature": "() -> bool",
        "doc": "Mounts the SPIFFS filesystem.\n\nReturns:\n    bool: True if the filesystem is successfully mounted, False otherwise."
      },
      {
        "name": "spiffs_end",
        "signature": "() -> None",
        "doc": "Unmounts the SPIFFS filesystem and releases resources."
      },
      {
        "name": "spiffs_format",
        "signature": "() -> bool",
        "doc": "Formats the SPIFFS filesystem.\n\nReturns:\n    bool: True if formatting succeeds, False otherwise."
      },
      {
        "name": "spiffs_open",
        "signature": "(path: str, mode: str) -> File",
        "doc": "Opens a file in the SPIFFS filesystem.\n\nArgs:\n    path (str): Path to the file.\n    mode (str): File mode (e.g., 'r', 'w', 'a').\n\nReturns:\n    File object or None: File handle if successful, None otherwise."
      },
      {
        "name": "spiffs_exists",
        "signature": "(path: str) -> bool",
        "doc": "Checks if a file or directory exists at the specified path.\n\nArgs:\n    path (str): Path to check.\n\nReturns:\n    bool: True if the path exists, False otherwise."
      },
      {
        "name": "spiffs_remove",
        "signature": "(path: str) -> bool",
        "doc": "Deletes a file from the SPIFFS filesystem.\n\nArgs:\n    path (str): Path of the file to delete.\n\nReturns:\n    bool: True if file is successfully removed, False otherwise."
      },
      {
        "name": "spiffs_rename",
        "signature": "(src: str, dest: str) -> bool",
        "doc": "Renames or moves a file.\n\nArgs:\n    src (str): Source file path.\n    dest (str): Destination file path.\n\nReturns:\n    bool: True if successful, False otherwise."
      },
      {
        "name": "spiffs_mkdir",
        "signature": "(path: str) -> bool",
        "doc": "Creates a directory in the SPIFFS filesystem.\n\nArgs:\n    path (str): Directory path.\n\nReturns:\n    bool: True if successful, False otherwise."
      },
      {
        "name": "spiffs_rmdir",
        "signature": "(path: str) -> bool",
        "doc": "Removes a directory from the SPIFFS filesystem.\n\nArgs:\n    path (str): Directory path.\n\nReturns:\n    bool: True if successful, False otherwise."
      },
      {
        "name": "spiffs_used_bytes",
        "signature": "() -> int",
        "doc": "Returns the number of bytes currently used in the SPIFFS filesystem.\n\nReturns:\n    int: Number of used bytes."
      },
      {
        "name": "spiffs_total_bytes",
        "signature": "() -> int",
        "doc": "Returns the total size of the SPIFFS filesystem.\n\nReturns:\n    int: Total number of bytes available."
      },
      {
        "name": "spiffs_free_bytes",
        "signature": "() -> int",
        "doc": "Returns the number of free bytes in the SPIFFS filesystem.\n\nReturns:\n    int: Number of free bytes available."
      },
      {
        "name": "spiffs_info",
        "signature": "() -> dict[str, str]",
        "doc": "Prints or returns general information about the SPIFFS filesystem.\n(Custom implementation required)"
      }
    ],
    "classes": [
      {
        "name": "File",
        "doc": "Represents a handle to an open file in the SPIFFS filesystem.\n\n class mirrors the behavior of the C++ `fs::File` class used with SPIFFS.\nYou should not create a File directly; instead, use `SPIFFS.open(path, mode)`\n(or in the transpiler, `spiffs_open(path, mode)`).\n\nThe File object allows reading, writing, and managing files in the\nSPIFFS or LittleFS filesystem on ESP32/ESP8266.",
        "methods": [
          {
            "name": "__init__",
            "signature": "(self) -> None",
            "doc": "Creates an empty File object.\nNormally, you obtain a File from `spiffs_open()`."
          },
          {
            "name": "write",
            "signature": "(self, data: str) -> int",
            "doc": "Writes data to the file.\n\nArgs:\n    data (str): The data to write to the file.\n\nReturns:\n    int: The number of bytes written."
          },
          {
            "name": "print",
            "signature": "(self, data: str) -> int",
            "doc": "Writes data to the file (without a newline).\n\nArgs:\n    data (str): The text to print.\n\nReturns:\n    int: The number of bytes written."
          },
          {
            "name": "println",
            "signature": "(self, data: str) -> int",
            "doc": "Writes data followed by a newline character to the file.\n\nArgs:\n    data (str): The text to print with a newline.\n\nReturns:\n    int: The number of bytes written."
          },
          {
            "name": "available",
            "signature": "(self) -> int",
            "doc": "Returns the number of bytes available for reading.\n\nReturns:\n    int: The number of bytes that can be read without blocking."
          },
          {
            "name": "size",
            "signature": "(self) -> int",
            "doc": "Returns the total size of the file in bytes.\n\nReturns:\n    int: The file size in bytes."
          },
          {
            "name": "position",
            "signature": "(self) -> int",
            "doc": "Returns the current position of the file cursor.\n\nReturns:\n    int: The current byte offset in the file."
          },
          {
            "name": "seek",
            "signature": "(self, pos: int, mode: int = 0) -> bool",
            "doc": "Moves the file cursor to a specific position.\n\nArgs:\n    pos (int): The byte position to move to.\n    mode (int, optional): The seek mode:\n        0 = SeekSet (absolute)\n        1 = SeekCur (relative)\n        2 = SeekEnd (from end)\n\nReturns:\n    bool: True if seek succeeded, False otherwise."
          },
          {
            "name": "close",
            "signature": "(self) -> None",
            "doc": "Closes the file handle and releases resources."
          },
          {
            "name": "is_directory",
            "signature": "(self) -> bool",
            "doc": "Checks whether  File object refers to a directory.\n\nReturns:\n    bool: True if  is a directory, False otherwise."
          },
          {
            "name": "name",
            "signature": "(self) -> str",
            "doc": "Returns the name (path) of the file.\n\nReturns:\n    str: The file name or path."
          },
          {
            "name": "rewind",
            "signature": "(self) -> None",
            "doc": "Resets the file cursor to the beginning of the file."
          },
          {
            "name": "read_string",
            "signature": "(self) -> str",
            "doc": "Reads the file content as a string until EOF.\n\nReturns:\n    str: The entire file content."
          },
          {
            "name": "peek",
            "signature": "(self) -> int",
            "doc": "Returns the next byte without advancing the file cursor.\n\nReturns:\n    int: The next byte as an integer, or -1 if end of file."
          },
          {
            "name": "flush",
            "signature": "(self) -> None",
            "doc": "Forces any buffered data to be written to storage."
          }
        ]
      }
    ],
    "variables": []
  }
}